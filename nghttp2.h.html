

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>nghttp2.h &mdash; nghttp2 0.7.8-DEV documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="nghttp2 0.7.8-DEV documentation" href="index.html"/>
        <link rel="next" title="nghttp2ver.h" href="nghttp2ver.h.html"/>
        <link rel="prev" title="Python API Reference" href="python-apiref.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="index.html" class="fa fa-home"> nghttp2</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="package_README.html">nghttp2 - HTTP/2 C Library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#development-status">Development Status</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#public-test-server">Public Test Server</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#requirements">Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#build-from-git">Build from git</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#building-documentation">Building documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#unit-tests">Unit tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#integration-tests">Integration tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#client-server-and-proxy-programs">Client, Server and Proxy programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#benchmarking-tool">Benchmarking tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#hpack-tools">HPACK tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#libnghttp2-asio-high-level-http-2-c-library">libnghttp2_asio: High level HTTP/2 C++ library</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#python-bindings">Python bindings</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#contribution">Contribution</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contribute.html">Contribution Guidelines</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contribute.html#coding-style">Coding style</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="building-android-binary.html">Building Android binary</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial-client.html">Tutorial: HTTP/2 client</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial-client.html#libevent-client-c">libevent-client.c</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial-server.html">Tutorial: HTTP/2 server</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial-server.html#libevent-server-c">libevent-server.c</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial-hpack.html">Tutorial: HPACK API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial-hpack.html#deflating-encoding-headers">Deflating (encoding) headers</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial-hpack.html#inflating-decoding-headers">Inflating (decoding) headers</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial-hpack.html#deflate-c">deflate.c</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nghttp.1.html">nghttp(1)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="nghttp.1.html#synopsis">SYNOPSIS</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttp.1.html#description">DESCRIPTION</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttp.1.html#options">OPTIONS</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttp.1.html#see-also">SEE ALSO</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nghttpd.1.html">nghttpd(1)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="nghttpd.1.html#synopsis">SYNOPSIS</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpd.1.html#description">DESCRIPTION</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpd.1.html#options">OPTIONS</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpd.1.html#see-also">SEE ALSO</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nghttpx.1.html">nghttpx(1)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="nghttpx.1.html#synopsis">SYNOPSIS</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx.1.html#description">DESCRIPTION</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx.1.html#options">OPTIONS</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx.1.html#files">FILES</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx.1.html#signals">SIGNALS</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx.1.html#server-push">SERVER PUSH</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx.1.html#unix-domain-socket">UNIX DOMAIN SOCKET</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx.1.html#see-also">SEE ALSO</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="h2load.1.html">h2load(1)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="h2load.1.html#synopsis">SYNOPSIS</a></li>
<li class="toctree-l2"><a class="reference internal" href="h2load.1.html#description">DESCRIPTION</a></li>
<li class="toctree-l2"><a class="reference internal" href="h2load.1.html#options">OPTIONS</a></li>
<li class="toctree-l2"><a class="reference internal" href="h2load.1.html#output">OUTPUT</a></li>
<li class="toctree-l2"><a class="reference internal" href="h2load.1.html#see-also">SEE ALSO</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nghttpx-howto.html">nghttpx - HTTP/2 proxy - HOW-TO</a><ul>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#default-mode">Default mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#http-2-proxy-mode">HTTP/2 proxy mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#client-mode">Client mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#client-proxy-mode">Client proxy mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#http-2-bridge-mode">HTTP/2 bridge mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#disable-ssl-tls">Disable SSL/TLS</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#specifying-additional-ca-certificate">Specifying additional CA certificate</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#read-write-rate-limit">Read/write rate limit</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#rewriting-location-header-field">Rewriting location header field</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#hot-swapping">Hot swapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#re-opening-log-files">Re-opening log files</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#multiple-backend-addresses">Multiple backend addresses</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="h2load-howto.html">h2load - HTTP/2 benchmarking tool - HOW-TO</a><ul>
<li class="toctree-l2"><a class="reference internal" href="h2load-howto.html#basic-usage">Basic Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="h2load-howto.html#flow-control">Flow Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="h2load-howto.html#multi-threading">Multi-Threading</a></li>
<li class="toctree-l2"><a class="reference internal" href="h2load-howto.html#selecting-protocol-for-clear-text">Selecting protocol for clear text</a></li>
<li class="toctree-l2"><a class="reference internal" href="h2load-howto.html#multiple-uris">Multiple URIs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="apiref.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="apiref.html#includes">Includes</a></li>
<li class="toctree-l2"><a class="reference internal" href="apiref.html#remarks">Remarks</a></li>
<li class="toctree-l2"><a class="reference internal" href="apiref.html#http-messaging">HTTP Messaging</a></li>
<li class="toctree-l2"><a class="reference internal" href="apiref.html#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="apiref.html#enums">Enums</a></li>
<li class="toctree-l2"><a class="reference internal" href="apiref.html#types-structs-unions-and-typedefs">Types (structs, unions and typedefs)</a></li>
<li class="toctree-l2"><a class="reference internal" href="apiref.html#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="libnghttp2_asio.html">libnghttp2_asio: High level HTTP/2 C++ library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="libnghttp2_asio.html#server-api">Server API</a></li>
<li class="toctree-l2"><a class="reference internal" href="libnghttp2_asio.html#client-api">Client API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="python-apiref.html">Python API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="python-apiref.html#hpack-api">HPACK API</a></li>
<li class="toctree-l2"><a class="reference internal" href="python-apiref.html#http-2-servers">HTTP/2 servers</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">nghttp2.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="nghttp2ver.h.html">nghttp2ver.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="asio_http2_server.h.html">asio_http2_server.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="asio_http2_client.h.html">asio_http2_client.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="asio_http2.h.html">asio_http2.h</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/tatsuhiro-t/nghttp2">Source</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/tatsuhiro-t/nghttp2/issues">Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://nghttp2.org/">nghttp2.org</a></li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">nghttp2</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>nghttp2.h</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="nghttp2-h">
<h1>nghttp2.h<a class="headerlink" href="#nghttp2-h" title="Permalink to this headline">Â¶</a></h1>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * nghttp2 - HTTP/2 C Library</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2013, 2014 Tatsuhiro Tsujikawa</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining</span>
<span class="cm"> * a copy of this software and associated documentation files (the</span>
<span class="cm"> * &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="cm"> * without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="cm"> * distribute, sublicense, and/or sell copies of the Software, and to</span>
<span class="cm"> * permit persons to whom the Software is furnished to do so, subject to</span>
<span class="cm"> * the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice shall be</span>
<span class="cm"> * included in all copies or substantial portions of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE</span>
<span class="cm"> * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION</span>
<span class="cm"> * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION</span>
<span class="cm"> * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef NGHTTP2_H</span>
<span class="cp">#define NGHTTP2_H</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;stdint.h&gt;</span>
<span class="cp">#include &lt;sys/types.h&gt;</span>

<span class="cp">#include &lt;nghttp2/nghttp2ver.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The protocol version identification string of this library</span>
<span class="cm"> * supports.  This identifier is used if HTTP/2 is used over TLS.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_PROTO_VERSION_ID &quot;h2-14&quot;</span>
<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The length of :macro:`NGHTTP2_PROTO_VERSION_ID`.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_PROTO_VERSION_ID_LEN 5</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The seriazlied form of ALPN protocol identifier this library</span>
<span class="cm"> * supports.  Notice that first byte is the length of following</span>
<span class="cm"> * protocol identifier.  This is the same wire format of `TLS ALPN</span>
<span class="cm"> * extension &lt;https://tools.ietf.org/html/rfc7301&gt;`_.  This is useful</span>
<span class="cm"> * to process incoming ALPN tokens in wire format.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_PROTO_ALPN &quot;\x5h2-14&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The length of :macro:`NGHTTP2_PROTO_ALPN`.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_PROTO_ALPN_LEN (sizeof(NGHTTP2_PROTO_ALPN) - 1)</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The protocol version identification string of this library</span>
<span class="cm"> * supports.  This identifier is used if HTTP/2 is used over cleartext</span>
<span class="cm"> * TCP.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_CLEARTEXT_PROTO_VERSION_ID &quot;h2c-14&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The length of :macro:`NGHTTP2_CLEARTEXT_PROTO_VERSION_ID`.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_CLEARTEXT_PROTO_VERSION_ID_LEN 6</span>

<span class="k">struct</span> <span class="n">nghttp2_session</span><span class="p">;</span>
<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The primary structure to hold the resources needed for a HTTP/2</span>
<span class="cm"> * session.  The details of this structure are intentionally hidden</span>
<span class="cm"> * from the public API.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">nghttp2_session</span> <span class="n">nghttp2_session</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The age of :type:`nghttp2_info`</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_VERSION_AGE 1</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * This struct is what `nghttp2_version()` returns.  It holds</span>
<span class="cm"> * information about the particular nghttp2 version.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * Age of this struct.  This instance of nghttp2 sets it to</span>
<span class="cm">   * :macro:`NGHTTP2_VERSION_AGE` but a future version may bump it and</span>
<span class="cm">   * add more struct fields at the bottom</span>
<span class="cm">   */</span>
  <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * the :macro:`NGHTTP2_VERSION_NUM` number (since age ==1)</span>
<span class="cm">   */</span>
  <span class="kt">int</span> <span class="n">version_num</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * points to the :macro:`NGHTTP2_VERSION` string (since age ==1)</span>
<span class="cm">   */</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">version_str</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * points to the :macro:`NGHTTP2_PROTO_VERSION_ID` string this</span>
<span class="cm">   * instance implements (since age ==1)</span>
<span class="cm">   */</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">proto_str</span><span class="p">;</span>
  <span class="cm">/* -------- the above fields all exist when age == 1 */</span>
<span class="p">}</span> <span class="n">nghttp2_info</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The default weight of stream dependency.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_DEFAULT_WEIGHT 16</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The maximum weight of stream dependency.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_MAX_WEIGHT 256</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The minimum weight of stream dependency.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_MIN_WEIGHT 1</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The maximum window size</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_MAX_WINDOW_SIZE ((int32_t)((1U &lt;&lt; 31) - 1))</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The initial window size for stream level flow control.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_INITIAL_WINDOW_SIZE ((1 &lt;&lt; 16) - 1)</span>
<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The initial window size for connection level flow control.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE ((1 &lt;&lt; 16) - 1)</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The default header table size.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_DEFAULT_HEADER_TABLE_SIZE (1 &lt;&lt; 12)</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The client connection preface.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_CLIENT_CONNECTION_PREFACE &quot;PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The length of :macro:`NGHTTP2_CLIENT_CONNECTION_PREFACE`.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_CLIENT_CONNECTION_PREFACE_LEN 24</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The client connection header.  This macro is obsoleted by</span>
<span class="cm"> * NGHTTP2_CLIENT_CONNECTION_PREFACE.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_CLIENT_CONNECTION_HEADER NGHTTP2_CLIENT_CONNECTION_PREFACE</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The length of :macro:`NGHTTP2_CLIENT_CONNECTION_HEADER`.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_CLIENT_CONNECTION_HEADER_LEN                                   \</span>
<span class="cp">  NGHTTP2_CLIENT_CONNECTION_PREFACE_LEN</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * Error codes used in this library.  The code range is [-999, -500],</span>
<span class="cm"> * inclusive. The following values are defined:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * Invalid argument passed.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INVALID_ARGUMENT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">501</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Out of buffer space.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_BUFFER_ERROR</span> <span class="o">=</span> <span class="o">-</span><span class="mi">502</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The specified protocol version is not supported.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_UNSUPPORTED_VERSION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">503</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Used as a return value from :type:`nghttp2_send_callback` and</span>
<span class="cm">   * :type:`nghttp2_recv_callback` to indicate that the operation</span>
<span class="cm">   * would block.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_WOULDBLOCK</span> <span class="o">=</span> <span class="o">-</span><span class="mi">504</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * General protocol error</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_PROTO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">505</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame is invalid.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INVALID_FRAME</span> <span class="o">=</span> <span class="o">-</span><span class="mi">506</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The peer performed a shutdown on the connection.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_EOF</span> <span class="o">=</span> <span class="o">-</span><span class="mi">507</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Used as a return value from</span>
<span class="cm">   * :func:`nghttp2_data_source_read_callback` to indicate that data</span>
<span class="cm">   * transfer is postponed.  See</span>
<span class="cm">   * :func:`nghttp2_data_source_read_callback` for details.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_DEFERRED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">508</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Stream ID has reached the maximum value.  Therefore no stream ID</span>
<span class="cm">   * is available.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">509</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The stream is already closed; or the stream ID is invalid.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_STREAM_CLOSED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">510</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * RST_STREAM has been added to the outbound queue.  The stream is</span>
<span class="cm">   * in closing state.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_STREAM_CLOSING</span> <span class="o">=</span> <span class="o">-</span><span class="mi">511</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The transmission is not allowed for this stream (e.g., a frame</span>
<span class="cm">   * with END_STREAM flag set has already sent).</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_STREAM_SHUT_WR</span> <span class="o">=</span> <span class="o">-</span><span class="mi">512</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The stream ID is invalid.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INVALID_STREAM_ID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">513</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The state of the stream is not valid (e.g., DATA cannot be sent</span>
<span class="cm">   * to the stream if response HEADERS has not been sent).</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INVALID_STREAM_STATE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">514</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Another DATA frame has already been deferred.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_DEFERRED_DATA_EXIST</span> <span class="o">=</span> <span class="o">-</span><span class="mi">515</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Starting new stream is not allowed (e.g., GOAWAY has been sent</span>
<span class="cm">   * and/or received).</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_START_STREAM_NOT_ALLOWED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">516</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * GOAWAY has already been sent.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_GOAWAY_ALREADY_SENT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">517</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The received frame contains the invalid header block (e.g., There</span>
<span class="cm">   * are duplicate header names; or the header names are not encoded</span>
<span class="cm">   * in US-ASCII character set and not lower cased; or the header name</span>
<span class="cm">   * is zero-length string; or the header value contains multiple</span>
<span class="cm">   * in-sequence NUL bytes).</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INVALID_HEADER_BLOCK</span> <span class="o">=</span> <span class="o">-</span><span class="mi">518</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Indicates that the context is not suitable to perform the</span>
<span class="cm">   * requested operation.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INVALID_STATE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">519</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The user callback function failed due to the temporal error.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">521</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the frame is invalid, either too large or too small.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_FRAME_SIZE_ERROR</span> <span class="o">=</span> <span class="o">-</span><span class="mi">522</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Header block inflate/deflate error.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_HEADER_COMP</span> <span class="o">=</span> <span class="o">-</span><span class="mi">523</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Flow control error</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_FLOW_CONTROL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">524</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Insufficient buffer size given to function.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INSUFF_BUFSIZE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">525</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Callback was paused by the application</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_PAUSE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">526</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * There are too many in-flight SETTING frame and no more</span>
<span class="cm">   * transmission of SETTINGS is allowed.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_TOO_MANY_INFLIGHT_SETTINGS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">527</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The server push is disabled.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_PUSH_DISABLED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">528</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * DATA frame for a given stream has been already submitted and has</span>
<span class="cm">   * not been fully processed yet.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_DATA_EXIST</span> <span class="o">=</span> <span class="o">-</span><span class="mi">529</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The current session is closing due to a connection error or</span>
<span class="cm">   * `nghttp2_session_terminate_session()` is called.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_SESSION_CLOSING</span> <span class="o">=</span> <span class="o">-</span><span class="mi">530</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Invalid HTTP header field was received and stream is going to be</span>
<span class="cm">   * closed.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_HTTP_HEADER</span> <span class="o">=</span> <span class="o">-</span><span class="mi">531</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The errors &lt; :enum:`NGHTTP2_ERR_FATAL` mean that the library is</span>
<span class="cm">   * under unexpected condition and processing was terminated (e.g.,</span>
<span class="cm">   * out of memory).  If application receives this error code, it must</span>
<span class="cm">   * stop using that :type:`nghttp2_session` object and only allowed</span>
<span class="cm">   * operation for that object is deallocate it using</span>
<span class="cm">   * `nghttp2_session_del()`.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_FATAL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">900</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Out of memory.  This is a fatal error.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_NOMEM</span> <span class="o">=</span> <span class="o">-</span><span class="mi">901</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The user callback function failed.  This is a fatal error.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_CALLBACK_FAILURE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">902</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Invalid connection preface was received and further processing is</span>
<span class="cm">   * not possible.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_BAD_PREFACE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">903</span>
<span class="p">}</span> <span class="n">nghttp2_error</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * The flags for header field name/value pair.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * No flag set.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_NV_FLAG_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Indicates that this name/value pair must not be indexed (&quot;Literal</span>
<span class="cm">   * Header Field never Indexed&quot; representation must be used in HPACK</span>
<span class="cm">   * encoding).  Other implementation calls this bit as &quot;sensitive&quot;.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_NV_FLAG_NO_INDEX</span> <span class="o">=</span> <span class="mh">0x01</span>
<span class="p">}</span> <span class="n">nghttp2_nv_flag</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The name/value pair, which mainly used to represent header fields.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The |name| byte string, which is not necessarily ``NULL``</span>
<span class="cm">   * terminated.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The |value| byte string, which is not necessarily ``NULL``</span>
<span class="cm">   * terminated.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the |name|.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">namelen</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the |value|.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">valuelen</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Bitwise OR of one or more of :type:`nghttp2_nv_flag`.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_nv</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * The frame types in HTTP/2 specification.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The DATA frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_DATA</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The HEADERS frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HEADERS</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The PRIORITY frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_PRIORITY</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The RST_STREAM frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_RST_STREAM</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The SETTINGS frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The PUSH_PROMISE frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_PUSH_PROMISE</span> <span class="o">=</span> <span class="mh">0x05</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The PING frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_PING</span> <span class="o">=</span> <span class="mh">0x06</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The GOAWAY frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_GOAWAY</span> <span class="o">=</span> <span class="mh">0x07</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The WINDOW_UPDATE frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_WINDOW_UPDATE</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The CONTINUATION frame.  This frame type won&#39;t be passed to any</span>
<span class="cm">   * callbacks because the library processes this frame type and its</span>
<span class="cm">   * preceding HEADERS/PUSH_PROMISE as a single frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_CONTINUATION</span> <span class="o">=</span> <span class="mh">0x09</span>
<span class="p">}</span> <span class="n">nghttp2_frame_type</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * The extension frame types.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: The assigned frame types were carried from draft-12, and now</span>
<span class="cm"> * actually TBD.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The ALTSVC extension frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_EXT_ALTSVC</span> <span class="o">=</span> <span class="mh">0x0a</span>
<span class="p">}</span> <span class="n">nghttp2_ext_frame_type</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * The flags for HTTP/2 frames.  This enum defines all flags for all</span>
<span class="cm"> * frames.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * No flag set.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The END_STREAM flag.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_END_STREAM</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The END_HEADERS flag.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_END_HEADERS</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The ACK flag.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_ACK</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The PADDED flag.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_PADDED</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The PRIORITY flag.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_PRIORITY</span> <span class="o">=</span> <span class="mh">0x20</span>
<span class="p">}</span> <span class="n">nghttp2_flag</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> * The SETTINGS ID.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_HEADER_TABLE_SIZE</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_HEADER_TABLE_SIZE</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_ENABLE_PUSH</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_ENABLE_PUSH</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_MAX_CONCURRENT_STREAMS</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_INITIAL_WINDOW_SIZE</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_MAX_FRAME_SIZE</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_MAX_FRAME_SIZE</span> <span class="o">=</span> <span class="mh">0x05</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_MAX_HEADER_LIST_SIZE</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE</span> <span class="o">=</span> <span class="mh">0x06</span>
<span class="p">}</span> <span class="n">nghttp2_settings_id</span><span class="p">;</span>
<span class="cm">/* Note: If we add SETTINGS, update the capacity of</span>
<span class="cm">   NGHTTP2_INBOUND_NUM_IV as well */</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> * Default maximum concurrent streams.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_INITIAL_MAX_CONCURRENT_STREAMS ((1U &lt;&lt; 31) - 1)</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> * The status codes for the RST_STREAM and GOAWAY frames.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * No errors.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_NO_ERROR</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * PROTOCOL_ERROR</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_PROTOCOL_ERROR</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * INTERNAL_ERROR</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_INTERNAL_ERROR</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * FLOW_CONTROL_ERROR</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLOW_CONTROL_ERROR</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_TIMEOUT</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_TIMEOUT</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * STREAM_CLOSED</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_STREAM_CLOSED</span> <span class="o">=</span> <span class="mh">0x05</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * FRAME_SIZE_ERROR</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FRAME_SIZE_ERROR</span> <span class="o">=</span> <span class="mh">0x06</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * REFUSED_STREAM</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_REFUSED_STREAM</span> <span class="o">=</span> <span class="mh">0x07</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * CANCEL</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_CANCEL</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * COMPRESSION_ERROR</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_COMPRESSION_ERROR</span> <span class="o">=</span> <span class="mh">0x09</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * CONNECT_ERROR</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_CONNECT_ERROR</span> <span class="o">=</span> <span class="mh">0x0a</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * ENHANCE_YOUR_CALM</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ENHANCE_YOUR_CALM</span> <span class="o">=</span> <span class="mh">0x0b</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * INADEQUATE_SECURITY</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_INADEQUATE_SECURITY</span> <span class="o">=</span> <span class="mh">0x0c</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * HTTP_1_1_REQUIRED</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HTTP_1_1_REQUIRED</span> <span class="o">=</span> <span class="mh">0x0d</span>
<span class="p">}</span> <span class="n">nghttp2_error_code</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> * The frame header.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The length field of this frame, excluding frame header.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">length</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The stream identifier (aka, stream ID)</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The type of this frame.  See `nghttp2_frame_type`.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">type</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The flags.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Reserved bit in frame header.  Currently, this is always set to 0</span>
<span class="cm">   * and application should not expect something useful in here.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_frame_hd</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @union</span>
<span class="cm"> *</span>
<span class="cm"> * This union represents the some kind of data source passed to</span>
<span class="cm"> * :type:`nghttp2_data_source_read_callback`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The integer field, suitable for a file descriptor.</span>
<span class="cm">   */</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The pointer to an arbitrary object.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_data_source</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * The flags used to set in |data_flags| output parameter in</span>
<span class="cm"> * :type:`nghttp2_data_source_read_callback`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * No flag set.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_DATA_FLAG_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Indicates EOF was sensed.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_DATA_FLAG_EOF</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Indicates that END_STREAM flag must not be set even if</span>
<span class="cm">   * NGHTTP2_DATA_FLAG_EOF is set.  Usually this flag is used to send</span>
<span class="cm">   * trailer header fields with `nghttp2_submit_request()` or</span>
<span class="cm">   * `nghttp2_submit_response()`.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_DATA_FLAG_NO_END_STREAM</span> <span class="o">=</span> <span class="mh">0x02</span>
<span class="p">}</span> <span class="n">nghttp2_data_flag</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when the library wants to read data from</span>
<span class="cm"> * the |source|.  The read data is sent in the stream |stream_id|.</span>
<span class="cm"> * The implementation of this function must read at most |length|</span>
<span class="cm"> * bytes of data from |source| (or possibly other places) and store</span>
<span class="cm"> * them in |buf| and return number of data stored in |buf|.  If EOF is</span>
<span class="cm"> * reached, set :enum:`NGHTTP2_DATA_FLAG_EOF` flag in |*data_flags|.</span>
<span class="cm"> *</span>
<span class="cm"> * If this callback is set by `nghttp2_submit_request()`,</span>
<span class="cm"> * `nghttp2_submit_response()` or `nghttp2_submit_headers()` and</span>
<span class="cm"> * `nghttp2_submit_data()` with flag parameter</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_END_STREAM` set, and</span>
<span class="cm"> * :enum:`NGHTTP2_DATA_FLAG_EOF` flag is set to |*data_flags|, DATA</span>
<span class="cm"> * frame will have END_STREAM flag set.  Usually, this is expected</span>
<span class="cm"> * behaviour and all are fine.  One exception is send trailer header</span>
<span class="cm"> * fields.  You cannot send trailers after sending frame with</span>
<span class="cm"> * END_STREAM set.  To avoid this problem, one can set</span>
<span class="cm"> * :enum:`NGHTTP2_DATA_FLAG_NO_END_STREAM` along with</span>
<span class="cm"> * :enum:`NGHTTP2_DATA_FLAG_EOF` to signal the library not to set</span>
<span class="cm"> * END_STREAM in DATA frame.  Then application can use</span>
<span class="cm"> * `nghttp2_submit_trailer()` to send trailers.</span>
<span class="cm"> * `nghttp2_submit_trailer()` can be called inside this callback.</span>
<span class="cm"> *</span>
<span class="cm"> * If the application wants to postpone DATA frames (e.g.,</span>
<span class="cm"> * asynchronous I/O, or reading data blocks for long time), it is</span>
<span class="cm"> * achieved by returning :enum:`NGHTTP2_ERR_DEFERRED` without reading</span>
<span class="cm"> * any data in this invocation.  The library removes DATA frame from</span>
<span class="cm"> * the outgoing queue temporarily.  To move back deferred DATA frame</span>
<span class="cm"> * to outgoing queue, call `nghttp2_session_resume_data()`.  In case</span>
<span class="cm"> * of error, there are 2 choices. Returning</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` will close the stream</span>
<span class="cm"> * by issuing RST_STREAM with :enum:`NGHTTP2_INTERNAL_ERROR`.  If a</span>
<span class="cm"> * different error code is desirable, use</span>
<span class="cm"> * `nghttp2_submit_rst_stream()` with a desired error code and then</span>
<span class="cm"> * return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  Returning</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` will signal the entire session</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_data_source_read_callback</span><span class="p">)(</span>
    <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span>
    <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">data_flags</span><span class="p">,</span> <span class="n">nghttp2_data_source</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * This struct represents the data source and the way to read a chunk</span>
<span class="cm"> * of data from it.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The data source.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_data_source</span> <span class="n">source</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The callback function to read a chunk of data from the |source|.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_data_source_read_callback</span> <span class="n">read_callback</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_data_provider</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The DATA frame.  The received data is delivered via</span>
<span class="cm"> * :type:`nghttp2_on_data_chunk_recv_callback`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the padding in this frame.  This includes PAD_HIGH</span>
<span class="cm">   * and PAD_LOW.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">padlen</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_data</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * The category of HEADERS, which indicates the role of the frame.  In</span>
<span class="cm"> * HTTP/2 spec, request, response, push response and other arbitrary</span>
<span class="cm"> * headers (e.g., trailers) are all called just HEADERS.  To give the</span>
<span class="cm"> * application the role of incoming HEADERS frame, we define several</span>
<span class="cm"> * categories.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The HEADERS frame is opening new stream, which is analogous to</span>
<span class="cm">   * SYN_STREAM in SPDY.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HCAT_REQUEST</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The HEADERS frame is the first response headers, which is</span>
<span class="cm">   * analogous to SYN_REPLY in SPDY.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HCAT_RESPONSE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The HEADERS frame is the first headers sent against reserved</span>
<span class="cm">   * stream.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HCAT_PUSH_RESPONSE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The HEADERS frame which does not apply for the above categories,</span>
<span class="cm">   * which is analogous to HEADERS in SPDY.  If non-final response</span>
<span class="cm">   * (e.g., status 1xx) is used, final response HEADERS frame will be</span>
<span class="cm">   * categorized here.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HCAT_HEADERS</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">}</span> <span class="n">nghttp2_headers_category</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The structure to specify stream dependency.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The stream ID of the stream to depend on.  Specifying 0 makes</span>
<span class="cm">   * stream not depend any other stream.</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The weight of this dependency.</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">weight</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * nonzero means exclusive dependency</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">exclusive</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_priority_spec</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The HEADERS frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the padding in this frame.  This includes PAD_HIGH</span>
<span class="cm">   * and PAD_LOW.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">padlen</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The priority specification</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_priority_spec</span> <span class="n">pri_spec</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The name/value pairs.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The number of name/value pairs in |nva|.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The category of this HEADERS frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_headers_category</span> <span class="n">cat</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_headers</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The PRIORITY frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The priority specification.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_priority_spec</span> <span class="n">pri_spec</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_priority</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The RST_STREAM frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The error code.  See :type:`nghttp2_error_code`.</span>
<span class="cm">   */</span>
  <span class="kt">uint32_t</span> <span class="n">error_code</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_rst_stream</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The SETTINGS ID/Value pair.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The SETTINGS ID.  See :type:`nghttp2_settings_id`.</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">settings_id</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The value of this entry.</span>
<span class="cm">   */</span>
  <span class="kt">uint32_t</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_settings_entry</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The SETTINGS frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The number of SETTINGS ID/Value pairs in |iv|.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">niv</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The pointer to the array of SETTINGS ID/Value pair.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_settings_entry</span> <span class="o">*</span><span class="n">iv</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_settings</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The PUSH_PROMISE frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the padding in this frame.  This includes PAD_HIGH</span>
<span class="cm">   * and PAD_LOW.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">padlen</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The name/value pairs.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The number of name/value pairs in |nva|.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The promised stream ID</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">promised_stream_id</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Reserved bit.  Currently this is always set to 0 and application</span>
<span class="cm">   * should not expect something useful in here.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_push_promise</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The PING frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The opaque data</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">opaque_data</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">}</span> <span class="n">nghttp2_ping</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The GOAWAY frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The last stream stream ID.</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">last_stream_id</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The error code.  See :type:`nghttp2_error_code`.</span>
<span class="cm">   */</span>
  <span class="kt">uint32_t</span> <span class="n">error_code</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The additional debug data</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">opaque_data</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of |opaque_data| member.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">opaque_data_len</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Reserved bit.  Currently this is always set to 0 and application</span>
<span class="cm">   * should not expect something useful in here.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_goaway</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The WINDOW_UPDATE frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The window size increment.</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">window_size_increment</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Reserved bit.  Currently this is always set to 0 and application</span>
<span class="cm">   * should not expect something useful in here.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_window_update</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The extension frame.  It has following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The pointer to extension payload.  The exact pointer type is</span>
<span class="cm">   * determined by hd.type.</span>
<span class="cm">   *</span>
<span class="cm">   * If hd.type == :enum:`NGHTTP2_EXT_ALTSVC`, it is a pointer to</span>
<span class="cm">   * :type:`nghttp2_ext_altsvc`.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_extension</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The ALTSVC extension frame payload.  It has following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * Protocol ID</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">protocol_id</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Host</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Origin</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">origin</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of |protocol_id|</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">protocol_id_len</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of |host|</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">host_len</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of |origin|</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">origin_len</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Max-Age</span>
<span class="cm">   */</span>
  <span class="kt">uint32_t</span> <span class="n">max_age</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Port</span>
<span class="cm">   */</span>
  <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_ext_altsvc</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @union</span>
<span class="cm"> *</span>
<span class="cm"> * This union includes all frames to pass them to various function</span>
<span class="cm"> * calls as nghttp2_frame type.  The CONTINUATION frame is omitted</span>
<span class="cm"> * from here because the library deals with it internally.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header, which is convenient to inspect frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The DATA frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_data</span> <span class="n">data</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The HEADERS frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_headers</span> <span class="n">headers</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The PRIORITY frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_priority</span> <span class="n">priority</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The RST_STREAM frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_rst_stream</span> <span class="n">rst_stream</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The SETTINGS frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_settings</span> <span class="n">settings</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The PUSH_PROMISE frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_push_promise</span> <span class="n">push_promise</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The PING frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_ping</span> <span class="n">ping</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The GOAWAY frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_goaway</span> <span class="n">goaway</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The WINDOW_UPDATE frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_window_update</span> <span class="n">window_update</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The extension frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_extension</span> <span class="n">ext</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_frame</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when |session| wants to send data to the</span>
<span class="cm"> * remote peer.  The implementation of this function must send at most</span>
<span class="cm"> * |length| bytes of data stored in |data|.  The |flags| is currently</span>
<span class="cm"> * not used and always 0. It must return the number of bytes sent if</span>
<span class="cm"> * it succeeds.  If it cannot send any single byte without blocking,</span>
<span class="cm"> * it must return :enum:`NGHTTP2_ERR_WOULDBLOCK`.  For other errors,</span>
<span class="cm"> * it must return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  The</span>
<span class="cm"> * |user_data| pointer is the third argument passed in to the call to</span>
<span class="cm"> * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This callback is required if the application uses</span>
<span class="cm"> * `nghttp2_session_send()` to send data to the remote endpoint.  If</span>
<span class="cm"> * the application uses solely `nghttp2_session_mem_send()` instead,</span>
<span class="cm"> * this callback function is unnecessary.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_send_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_send_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span>
                                         <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when |session| wants to receive data from</span>
<span class="cm"> * the remote peer.  The implementation of this function must read at</span>
<span class="cm"> * most |length| bytes of data and store it in |buf|.  The |flags| is</span>
<span class="cm"> * currently not used and always 0.  It must return the number of</span>
<span class="cm"> * bytes written in |buf| if it succeeds.  If it cannot read any</span>
<span class="cm"> * single byte without blocking, it must return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_WOULDBLOCK`.  If it gets EOF before it reads any</span>
<span class="cm"> * single byte, it must return :enum:`NGHTTP2_ERR_EOF`.  For other</span>
<span class="cm"> * errors, it must return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> * Returning 0 is treated as :enum:`NGHTTP2_ERR_WOULDBLOCK`.  The</span>
<span class="cm"> * |user_data| pointer is the third argument passed in to the call to</span>
<span class="cm"> * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This callback is required if the application uses</span>
<span class="cm"> * `nghttp2_session_recv()` to receive data from the remote endpoint.</span>
<span class="cm"> * If the application uses solely `nghttp2_session_mem_recv()`</span>
<span class="cm"> * instead, this callback function is unnecessary.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_recv_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_recv_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
                                         <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
                                         <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked by `nghttp2_session_recv()` when a frame</span>
<span class="cm"> * is received.  The |user_data| pointer is the third argument passed</span>
<span class="cm"> * in to the call to `nghttp2_session_client_new()` or</span>
<span class="cm"> * `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * If frame is HEADERS or PUSH_PROMISE, the ``nva`` and ``nvlen``</span>
<span class="cm"> * member of their data structure are always ``NULL`` and 0</span>
<span class="cm"> * respectively.  The header name/value pairs are emitted via</span>
<span class="cm"> * :type:`nghttp2_on_header_callback`.</span>
<span class="cm"> *</span>
<span class="cm"> * For HEADERS, PUSH_PROMISE and DATA frames, this callback may be</span>
<span class="cm"> * called after stream is closed (see</span>
<span class="cm"> * :type:`nghttp2_on_stream_close_callback`).  The application should</span>
<span class="cm"> * check that stream is still alive using its own stream management or</span>
<span class="cm"> * :func:`nghttp2_session_get_stream_user_data()`.</span>
<span class="cm"> *</span>
<span class="cm"> * Only HEADERS and DATA frame can signal the end of incoming data.</span>
<span class="cm"> * If ``frame-&gt;hd.flags &amp; NGHTTP2_FLAG_END_STREAM`` is nonzero, the</span>
<span class="cm"> * |frame| is the last frame from the remote peer in this stream.</span>
<span class="cm"> *</span>
<span class="cm"> * This callback won&#39;t be called for CONTINUATION frames.</span>
<span class="cm"> * HEADERS/PUSH_PROMISE + CONTINUATIONs are treated as single frame.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero value is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_frame_recv_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_frame_recv_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
                                              <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked by `nghttp2_session_recv()` when an</span>
<span class="cm"> * invalid non-DATA frame is received.  The |error_code| indicates the</span>
<span class="cm"> * error.  It is usually one of the :enum:`nghttp2_error_code` but</span>
<span class="cm"> * that is not guaranteed.  When this callback function is invoked,</span>
<span class="cm"> * the library automatically submits either RST_STREAM or GOAWAY</span>
<span class="cm"> * frame.  The |user_data| pointer is the third argument passed in to</span>
<span class="cm"> * the call to `nghttp2_session_client_new()` or</span>
<span class="cm"> * `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * If frame is HEADERS or PUSH_PROMISE, the ``nva`` and ``nvlen``</span>
<span class="cm"> * member of their data structure are always ``NULL`` and 0</span>
<span class="cm"> * respectively.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_send()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_invalid_frame_recv_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_invalid_frame_recv_callback</span><span class="p">)(</span>
    <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">error_code</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when a chunk of data in DATA frame is</span>
<span class="cm"> * received.  The |stream_id| is the stream ID this DATA frame belongs</span>
<span class="cm"> * to.  The |flags| is the flags of DATA frame which this data chunk</span>
<span class="cm"> * is contained.  ``(flags &amp; NGHTTP2_FLAG_END_STREAM) != 0`` does not</span>
<span class="cm"> * necessarily mean this chunk of data is the last one in the stream.</span>
<span class="cm"> * You should use :type:`nghttp2_on_frame_recv_callback` to know all</span>
<span class="cm"> * data frames are received.  The |user_data| pointer is the third</span>
<span class="cm"> * argument passed in to the call to `nghttp2_session_client_new()` or</span>
<span class="cm"> * `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * If the application uses `nghttp2_session_mem_recv()`, it can return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PAUSE` to make `nghttp2_session_mem_recv()`</span>
<span class="cm"> * return without processing further input bytes.  The memory by</span>
<span class="cm"> * pointed by the |data| is retained until</span>
<span class="cm"> * `nghttp2_session_mem_recv()` or `nghttp2_session_recv()` is called.</span>
<span class="cm"> * The application must retain the input bytes which was used to</span>
<span class="cm"> * produce the |data| parameter, because it may refer to the memory</span>
<span class="cm"> * region included in the input bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_data_chunk_recv_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_data_chunk_recv_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                   <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                                                   <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                                   <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
                                                   <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked just before the non-DATA frame |frame| is</span>
<span class="cm"> * sent.  The |user_data| pointer is the third argument passed in to</span>
<span class="cm"> * the call to `nghttp2_session_client_new()` or</span>
<span class="cm"> * `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_send()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_before_frame_send_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_before_frame_send_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                  <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
                                                  <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked after the frame |frame| is sent.  The</span>
<span class="cm"> * |user_data| pointer is the third argument passed in to the call to</span>
<span class="cm"> * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_send()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_frame_send_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_frame_send_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
                                              <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked after the non-DATA frame |frame| is not</span>
<span class="cm"> * sent because of the error.  The error is indicated by the</span>
<span class="cm"> * |lib_error_code|, which is one of the values defined in</span>
<span class="cm"> * :type:`nghttp2_error`.  The |user_data| pointer is the third</span>
<span class="cm"> * argument passed in to the call to `nghttp2_session_client_new()` or</span>
<span class="cm"> * `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_send()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * `nghttp2_session_get_stream_user_data()` can be used to get</span>
<span class="cm"> * associated data.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_frame_not_send_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_frame_not_send_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                  <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
                                                  <span class="kt">int</span> <span class="n">lib_error_code</span><span class="p">,</span>
                                                  <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when the stream |stream_id| is closed.</span>
<span class="cm"> * The reason of closure is indicated by the |error_code|.  The</span>
<span class="cm"> * |error_code| is usually one of :enum:`nghttp2_error_code`, but that</span>
<span class="cm"> * is not guaranteed.  The stream_user_data, which was specified in</span>
<span class="cm"> * `nghttp2_submit_request()` or `nghttp2_submit_headers()`, is still</span>
<span class="cm"> * available in this function.  The |user_data| pointer is the third</span>
<span class="cm"> * argument passed in to the call to `nghttp2_session_client_new()` or</span>
<span class="cm"> * `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is also called for a stream in reserved state.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_send()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_stream_close_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_stream_close_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                                <span class="kt">uint32_t</span> <span class="n">error_code</span><span class="p">,</span>
                                                <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when the reception of header block in</span>
<span class="cm"> * HEADERS or PUSH_PROMISE is started.  Each header name/value pair</span>
<span class="cm"> * will be emitted by :type:`nghttp2_on_header_callback`.</span>
<span class="cm"> *</span>
<span class="cm"> * The ``frame-&gt;hd.flags`` may not have</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_END_HEADERS` flag set, which indicates that one</span>
<span class="cm"> * or more CONTINUATION frames are involved.  But the application does</span>
<span class="cm"> * not need to care about that because the header name/value pairs are</span>
<span class="cm"> * emitted transparently regardless of CONTINUATION frames.</span>
<span class="cm"> *</span>
<span class="cm"> * The server applications probably create an object to store</span>
<span class="cm"> * information about new stream if ``frame-&gt;hd.type ==</span>
<span class="cm"> * NGHTTP2_HEADERS`` and ``frame-&gt;headers.cat ==</span>
<span class="cm"> * NGHTTP2_HCAT_REQUEST``.  If |session| is configured as server side,</span>
<span class="cm"> * ``frame-&gt;headers.cat`` is either ``NGHTTP2_HCAT_REQUEST``</span>
<span class="cm"> * containing request headers or ``NGHTTP2_HCAT_HEADERS`` containing</span>
<span class="cm"> * trailer headers and never get PUSH_PROMISE in this callback.</span>
<span class="cm"> *</span>
<span class="cm"> * For the client applications, ``frame-&gt;hd.type`` is either</span>
<span class="cm"> * ``NGHTTP2_HEADERS`` or ``NGHTTP2_PUSH_PROMISE``.  In case of</span>
<span class="cm"> * ``NGHTTP2_HEADERS``, ``frame-&gt;headers.cat ==</span>
<span class="cm"> * NGHTTP2_HCAT_RESPONSE`` means that it is the first response</span>
<span class="cm"> * headers, but it may be non-final response which is indicated by 1xx</span>
<span class="cm"> * status code.  In this case, there may be zero or more HEADERS frame</span>
<span class="cm"> * with ``frame-&gt;headers.cat == NGHTTP2_HCAT_HEADERS`` which has</span>
<span class="cm"> * non-final response code and finally client gets exactly one HEADERS</span>
<span class="cm"> * frame with ``frame-&gt;headers.cat == NGHTTP2_HCAT_HEADERS``</span>
<span class="cm"> * containing final response headers (non-1xx status code).  The</span>
<span class="cm"> * trailer headers also has ``frame-&gt;headers.cat ==</span>
<span class="cm"> * NGHTTP2_HCAT_HEADERS`` which does not containg any status code.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds or</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If nonzero value other than</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned, it is treated as</span>
<span class="cm"> * if :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned.  If</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned,</span>
<span class="cm"> * `nghttp2_session_mem_recv()` function will immediately return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_begin_headers_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_begin_headers_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                 <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
                                                 <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when a header name/value pair is received</span>
<span class="cm"> * for the |frame|.  The |name| of length |namelen| is header name.</span>
<span class="cm"> * The |value| of length |valuelen| is header value.  The |flags| is</span>
<span class="cm"> * bitwise OR of one or more of :type:`nghttp2_nv_flag`.</span>
<span class="cm"> *</span>
<span class="cm"> * If :enum:`NGHTTP2_NV_FLAG_NO_INDEX` is set in |flags|, the receiver</span>
<span class="cm"> * must not index this name/value pair when forwarding it to the next</span>
<span class="cm"> * hop.  More specifically, &quot;Literal Header Field never Indexed&quot;</span>
<span class="cm"> * representation must be used in HPACK encoding.</span>
<span class="cm"> *</span>
<span class="cm"> * When this callback is invoked, ``frame-&gt;hd.type`` is either</span>
<span class="cm"> * :enum:`NGHTTP2_HEADERS` or :enum:`NGHTTP2_PUSH_PROMISE`.  After all</span>
<span class="cm"> * header name/value pairs are processed with this callback, and no</span>
<span class="cm"> * error has been detected, :type:`nghttp2_on_frame_recv_callback`</span>
<span class="cm"> * will be invoked.  If there is an error in decompression,</span>
<span class="cm"> * :type:`nghttp2_on_frame_recv_callback` for the |frame| will not be</span>
<span class="cm"> * invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * The |value| may be ``NULL`` if the |valuelen| is 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Please note that unless `nghttp2_option_set_no_http_messaging()` is</span>
<span class="cm"> * used, nghttp2 library does perform validation against the |name|</span>
<span class="cm"> * and the |value| using `nghttp2_check_header_name()` and</span>
<span class="cm"> * `nghttp2_check_header_value()`.  In addition to this, nghttp2</span>
<span class="cm"> * performs vaidation based on HTTP Messaging rule, which is briefly</span>
<span class="cm"> * explained in `HTTP Messaging`_ section.</span>
<span class="cm"> *</span>
<span class="cm"> * If the application uses `nghttp2_session_mem_recv()`, it can return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PAUSE` to make `nghttp2_session_mem_recv()`</span>
<span class="cm"> * return without processing further input bytes.  The memory pointed</span>
<span class="cm"> * by |frame|, |name| and |value| parameters are retained until</span>
<span class="cm"> * `nghttp2_session_mem_recv()` or `nghttp2_session_recv()` is called.</span>
<span class="cm"> * The application must retain the input bytes which was used to</span>
<span class="cm"> * produce these parameters, because it may refer to the memory region</span>
<span class="cm"> * included in the input bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * Returning :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` will close</span>
<span class="cm"> * the stream by issuing RST_STREAM with</span>
<span class="cm"> * :enum:`NGHTTP2_INTERNAL_ERROR`.  In this case,</span>
<span class="cm"> * :type:`nghttp2_on_frame_recv_callback` will not be invoked.  If a</span>
<span class="cm"> * different error code is desirable, use</span>
<span class="cm"> * `nghttp2_submit_rst_stream()` with a desired error code and then</span>
<span class="cm"> * return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * It may return :enum:`NGHTTP2_ERR_PAUSE` or</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  For other critical</span>
<span class="cm"> * failures, it must return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If</span>
<span class="cm"> * the other nonzero value is returned, it is treated as</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned,</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_header_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_header_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                          <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
                                          <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">namelen</span><span class="p">,</span>
                                          <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">valuelen</span><span class="p">,</span>
                                          <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when the library asks application how</span>
<span class="cm"> * many padding bytes are required for the transmission of the</span>
<span class="cm"> * |frame|.  The application must choose the total length of payload</span>
<span class="cm"> * including padded bytes in range [frame-&gt;hd.length, max_payloadlen],</span>
<span class="cm"> * inclusive.  Choosing number not in this range will be treated as</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  Returning</span>
<span class="cm"> * ``frame-&gt;hd.length`` means no padding is added.  Returning</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` will make</span>
<span class="cm"> * `nghttp2_session_send()` function immediately return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_select_padding_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_select_padding_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                   <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
                                                   <span class="kt">size_t</span> <span class="n">max_payloadlen</span><span class="p">,</span>
                                                   <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when library wants to get max length of</span>
<span class="cm"> * data to send data to the remote peer.  The implementation of this</span>
<span class="cm"> * function should return a value in the following range.  [1,</span>
<span class="cm"> * min(|session_remote_window_size|, |stream_remote_window_size|,</span>
<span class="cm"> * |remote_max_frame_size|)].  If a value greater than this range is</span>
<span class="cm"> * returned than the max allow value will be used.  Returning a value</span>
<span class="cm"> * smaller than this range is treated as</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  The |frame_type| is provided</span>
<span class="cm"> * for future extensibility and identifies the type of frame (see</span>
<span class="cm"> * :type:`nghttp2_frame_type`) for which to get the length for.</span>
<span class="cm"> * Currently supported frame types are: :enum:`NGHTTP2_DATA`.</span>
<span class="cm"> *</span>
<span class="cm"> * This callback can be used to control the length in bytes for which</span>
<span class="cm"> * :type:`nghttp2_data_source_read_callback` is allowed to send to the</span>
<span class="cm"> * remote endpoint.  This callback is optional.  Returning</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` will signal the entire session</span>
<span class="cm"> * failure.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_data_source_read_length_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_data_source_read_length_callback</span><span class="p">)(</span>
    <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">frame_type</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
    <span class="kt">int32_t</span> <span class="n">session_remote_window_size</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_remote_window_size</span><span class="p">,</span>
    <span class="kt">uint32_t</span> <span class="n">remote_max_frame_size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when a frame header is received.  The</span>
<span class="cm"> * |hd| points to received frame header.</span>
<span class="cm"> *</span>
<span class="cm"> * Unlike :type:`nghttp2_on_frame_recv_callback`, this callback will</span>
<span class="cm"> * also be called when frame header of CONTINUATION frame is received.</span>
<span class="cm"> *</span>
<span class="cm"> * If both :type:`nghttp2_on_begin_frame_callback` and</span>
<span class="cm"> * :type:`nghttp2_on_begin_headers_callback` are set and HEADERS or</span>
<span class="cm"> * PUSH_PROMISE is received, :type:`nghttp2_on_begin_frame_callback`</span>
<span class="cm"> * will be called first.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero value is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_begin_frame_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_begin_frame_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                               <span class="k">const</span> <span class="n">nghttp2_frame_hd</span> <span class="o">*</span><span class="n">hd</span><span class="p">,</span>
                                               <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">nghttp2_session_callbacks</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * Callback functions for :type:`nghttp2_session`.  The details of</span>
<span class="cm"> * this structure are intentionally hidden from the public API.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">nghttp2_session_callbacks</span> <span class="n">nghttp2_session_callbacks</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |*callbacks_ptr| with NULL values.</span>
<span class="cm"> *</span>
<span class="cm"> * The initialized object can be used when initializing multiple</span>
<span class="cm"> * :type:`nghttp2_session` objects.</span>
<span class="cm"> *</span>
<span class="cm"> * When the application finished using this object, it can use</span>
<span class="cm"> * `nghttp2_session_callbacks_del()` to free its memory.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_callbacks_new</span><span class="p">(</span><span class="n">nghttp2_session_callbacks</span> <span class="o">**</span><span class="n">callbacks_ptr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Frees any resources allocated for |callbacks|.  If |callbacks| is</span>
<span class="cm"> * ``NULL``, this function does nothing.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_del</span><span class="p">(</span><span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when a session wants to send data to</span>
<span class="cm"> * the remote peer.  This callback is not necessary if the application</span>
<span class="cm"> * uses solely `nghttp2_session_mem_send()` to serialize data to</span>
<span class="cm"> * transmit.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_send_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span> <span class="n">nghttp2_send_callback</span> <span class="n">send_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when the a session wants to receive</span>
<span class="cm"> * data from the remote peer.  This callback is not necessary if the</span>
<span class="cm"> * application uses solely `nghttp2_session_mem_recv()` to process</span>
<span class="cm"> * received data.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_recv_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span> <span class="n">nghttp2_recv_callback</span> <span class="n">recv_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked by `nghttp2_session_recv()` when a</span>
<span class="cm"> * frame is received.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_frame_recv_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_frame_recv_callback</span> <span class="n">on_frame_recv_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked by `nghttp2_session_recv()` when an</span>
<span class="cm"> * invalid non-DATA frame is received.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_invalid_frame_recv_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_invalid_frame_recv_callback</span> <span class="n">on_invalid_frame_recv_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when a chunk of data in DATA frame</span>
<span class="cm"> * is received.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_data_chunk_recv_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_data_chunk_recv_callback</span> <span class="n">on_data_chunk_recv_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked before a non-DATA frame is sent.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_before_frame_send_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_before_frame_send_callback</span> <span class="n">before_frame_send_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked after a frame is sent.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_frame_send_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_frame_send_callback</span> <span class="n">on_frame_send_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when a non-DATA frame is not sent</span>
<span class="cm"> * because of an error.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_frame_not_send_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_frame_not_send_callback</span> <span class="n">on_frame_not_send_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when the stream is closed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_stream_close_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_stream_close_callback</span> <span class="n">on_stream_close_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when the reception of header block</span>
<span class="cm"> * in HEADERS or PUSH_PROMISE is started.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_begin_headers_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_begin_headers_callback</span> <span class="n">on_begin_headers_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when a header name/value pair is</span>
<span class="cm"> * received.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_header_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_header_callback</span> <span class="n">on_header_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when the library asks application</span>
<span class="cm"> * how many padding bytes are required for the transmission of the</span>
<span class="cm"> * given frame.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_select_padding_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_select_padding_callback</span> <span class="n">select_padding_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function determine the length allowed in</span>
<span class="cm"> * :type:`nghttp2_data_source_read_callback`.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_data_source_read_length_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_data_source_read_length_callback</span> <span class="n">data_source_read_length_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when a frame header is received.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_begin_frame_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_begin_frame_callback</span> <span class="n">on_begin_frame_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Custom memory allocator to replace malloc().  The |mem_user_data|</span>
<span class="cm"> * is the mem_user_data member of :type:`nghttp2_mem` structure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">nghttp2_malloc</span><span class="p">)(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mem_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Custom memory allocator to replace free().  The |mem_user_data| is</span>
<span class="cm"> * the mem_user_data member of :type:`nghttp2_mem` structure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_free</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mem_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Custom memory allocator to replace calloc().  The |mem_user_data|</span>
<span class="cm"> * is the mem_user_data member of :type:`nghttp2_mem` structure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">nghttp2_calloc</span><span class="p">)(</span><span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mem_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Custom memory allocator to replace realloc().  The |mem_user_data|</span>
<span class="cm"> * is the mem_user_data member of :type:`nghttp2_mem` structure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">nghttp2_realloc</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mem_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * Custom memory allocator functions and user defined pointer.  The</span>
<span class="cm"> * |mem_user_data| member is passed to each allocator function.  This</span>
<span class="cm"> * can be used, for example, to achieve per-session memory pool.</span>
<span class="cm"> *</span>
<span class="cm"> * In the following example code, ``my_malloc``, ``my_free``,</span>
<span class="cm"> * ``my_calloc`` and ``my_realloc`` are the replacement of the</span>
<span class="cm"> * standard allocators ``malloc``, ``free``, ``calloc`` and</span>
<span class="cm"> * ``realloc`` respectively::</span>
<span class="cm"> *</span>
<span class="cm"> *     void *my_malloc_cb(size_t size, void *mem_user_data) {</span>
<span class="cm"> *       return my_malloc(size);</span>
<span class="cm"> *     }</span>
<span class="cm"> *</span>
<span class="cm"> *     void my_free_cb(void *ptr, void *mem_user_data) { my_free(ptr); }</span>
<span class="cm"> *</span>
<span class="cm"> *     void *my_calloc_cb(size_t nmemb, size_t size, void *mem_user_data) {</span>
<span class="cm"> *       return my_calloc(nmemb, size);</span>
<span class="cm"> *     }</span>
<span class="cm"> *</span>
<span class="cm"> *     void *my_realloc_cb(void *ptr, size_t size, void *mem_user_data) {</span>
<span class="cm"> *       return my_realloc(ptr, size);</span>
<span class="cm"> *     }</span>
<span class="cm"> *</span>
<span class="cm"> *     void session_new() {</span>
<span class="cm"> *       nghttp2_session *session;</span>
<span class="cm"> *       nghttp2_session_callbacks *callbacks;</span>
<span class="cm"> *       nghttp2_mem mem = {NULL, my_malloc_cb, my_free_cb, my_calloc_cb,</span>
<span class="cm"> *                          my_realloc_cb};</span>
<span class="cm"> *</span>
<span class="cm"> *       ...</span>
<span class="cm"> *</span>
<span class="cm"> *       nghttp2_session_client_new3(&amp;session, callbacks, NULL, NULL, &amp;mem);</span>
<span class="cm"> *</span>
<span class="cm"> *       ...</span>
<span class="cm"> *     }</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * An arbitrary user supplied data.  This is passed to each</span>
<span class="cm">   * allocator function.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">mem_user_data</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Custom allocator function to replace malloc().</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_malloc</span> <span class="n">malloc</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Custom allocator function to replace free().</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_free</span> <span class="n">free</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Custom allocator function to replace calloc().</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_calloc</span> <span class="n">calloc</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Custom allocator function to replace realloc().</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_realloc</span> <span class="n">realloc</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_mem</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">nghttp2_option</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * Configuration options for :type:`nghttp2_session`.  The details of</span>
<span class="cm"> * this structure are intentionally hidden from the public API.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">nghttp2_option</span> <span class="n">nghttp2_option</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |*option_ptr| with default values.</span>
<span class="cm"> *</span>
<span class="cm"> * When the application finished using this object, it can use</span>
<span class="cm"> * `nghttp2_option_del()` to free its memory.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_option_new</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">**</span><span class="n">option_ptr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Frees any resources allocated for |option|.  If |option| is</span>
<span class="cm"> * ``NULL``, this function does nothing.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_option_del</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * This option prevents the library from sending WINDOW_UPDATE for a</span>
<span class="cm"> * connection automatically.  If this option is set to nonzero, the</span>
<span class="cm"> * library won&#39;t send WINDOW_UPDATE for DATA until application calls</span>
<span class="cm"> * `nghttp2_session_consume()` to indicate the consumed amount of</span>
<span class="cm"> * data.  Don&#39;t use `nghttp2_submit_window_update()` for this purpose.</span>
<span class="cm"> * By default, this option is set to zero.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_option_set_no_auto_window_update</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * This option sets the SETTINGS_MAX_CONCURRENT_STREAMS value of</span>
<span class="cm"> * remote endpoint as if it is received in SETTINGS frame.  Without</span>
<span class="cm"> * specifying this option, before the local endpoint receives</span>
<span class="cm"> * SETTINGS_MAX_CONCURRENT_STREAMS in SETTINGS frame from remote</span>
<span class="cm"> * endpoint, SETTINGS_MAX_CONCURRENT_STREAMS is unlimited.  This may</span>
<span class="cm"> * cause problem if local endpoint submits lots of requests initially</span>
<span class="cm"> * and sending them at once to the remote peer may lead to the</span>
<span class="cm"> * rejection of some requests.  Specifying this option to the sensible</span>
<span class="cm"> * value, say 100, may avoid this kind of issue. This value will be</span>
<span class="cm"> * overwritten if the local endpoint receives</span>
<span class="cm"> * SETTINGS_MAX_CONCURRENT_STREAMS from the remote endpoint.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_option_set_peer_max_concurrent_streams</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span>
                                                    <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * By default, nghttp2 library only handles HTTP/2 frames and does not</span>
<span class="cm"> * recognize first 24 bytes of client connection preface.  This design</span>
<span class="cm"> * choice is done due to the fact that server may want to detect the</span>
<span class="cm"> * application protocol based on first few bytes on clear text</span>
<span class="cm"> * communication.  But for simple servers which only speak HTTP/2, it</span>
<span class="cm"> * is easier for developers if nghttp2 library takes care of client</span>
<span class="cm"> * connection preface.</span>
<span class="cm"> *</span>
<span class="cm"> * If this option is used with nonzero |val|, nghttp2 library checks</span>
<span class="cm"> * first 24 bytes client connection preface.  If it is not a valid</span>
<span class="cm"> * one, `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` will</span>
<span class="cm"> * return error :enum:`NGHTTP2_ERR_BAD_PREFACE`, which is fatal error.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_option_set_recv_client_preface</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * By default, nghttp2 library enforces subset of HTTP Messaging rules</span>
<span class="cm"> * described in `HTTP/2 specification, section 8</span>
<span class="cm"> * &lt;https://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8&gt;`_.</span>
<span class="cm"> * See `HTTP Messaging`_ section for details.  For those applications</span>
<span class="cm"> * who use nghttp2 library as non-HTTP use, give nonzero to |val| to</span>
<span class="cm"> * disable this enforcement.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_option_set_no_http_messaging</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |*session_ptr| for client use.  The all members of</span>
<span class="cm"> * |callbacks| are copied to |*session_ptr|.  Therefore |*session_ptr|</span>
<span class="cm"> * does not store |callbacks|.  The |user_data| is an arbitrary user</span>
<span class="cm"> * supplied data, which will be passed to the callback functions.</span>
<span class="cm"> *</span>
<span class="cm"> * The :type:`nghttp2_send_callback` must be specified.  If the</span>
<span class="cm"> * application code uses `nghttp2_session_recv()`, the</span>
<span class="cm"> * :type:`nghttp2_recv_callback` must be specified.  The other members</span>
<span class="cm"> * of |callbacks| can be ``NULL``.</span>
<span class="cm"> *</span>
<span class="cm"> * If this function fails, |*session_ptr| is left untouched.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_client_new</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">**</span><span class="n">session_ptr</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">,</span>
                               <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |*session_ptr| for server use.  The all members of</span>
<span class="cm"> * |callbacks| are copied to |*session_ptr|. Therefore |*session_ptr|</span>
<span class="cm"> * does not store |callbacks|.  The |user_data| is an arbitrary user</span>
<span class="cm"> * supplied data, which will be passed to the callback functions.</span>
<span class="cm"> *</span>
<span class="cm"> * The :type:`nghttp2_send_callback` must be specified.  If the</span>
<span class="cm"> * application code uses `nghttp2_session_recv()`, the</span>
<span class="cm"> * :type:`nghttp2_recv_callback` must be specified.  The other members</span>
<span class="cm"> * of |callbacks| can be ``NULL``.</span>
<span class="cm"> *</span>
<span class="cm"> * If this function fails, |*session_ptr| is left untouched.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_server_new</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">**</span><span class="n">session_ptr</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">,</span>
                               <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Like `nghttp2_session_client_new()`, but with additional options</span>
<span class="cm"> * specified in the |option|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |option| can be ``NULL`` and the call is equivalent to</span>
<span class="cm"> * `nghttp2_session_client_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership |option|.  The application is</span>
<span class="cm"> * responsible for freeing |option| if it finishes using the object.</span>
<span class="cm"> *</span>
<span class="cm"> * The library code does not refer to |option| after this function</span>
<span class="cm"> * returns.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_client_new2</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">**</span><span class="n">session_ptr</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">,</span>
                                <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Like `nghttp2_session_server_new()`, but with additional options</span>
<span class="cm"> * specified in the |option|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |option| can be ``NULL`` and the call is equivalent to</span>
<span class="cm"> * `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership |option|.  The application is</span>
<span class="cm"> * responsible for freeing |option| if it finishes using the object.</span>
<span class="cm"> *</span>
<span class="cm"> * The library code does not refer to |option| after this function</span>
<span class="cm"> * returns.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_server_new2</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">**</span><span class="n">session_ptr</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">,</span>
                                <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Like `nghttp2_session_client_new2()`, but with additional custom</span>
<span class="cm"> * memory allocator specified in the |mem|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |mem| can be ``NULL`` and the call is equivalent to</span>
<span class="cm"> * `nghttp2_session_client_new2()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership |mem|.  The application is</span>
<span class="cm"> * responsible for freeing |mem|.</span>
<span class="cm"> *</span>
<span class="cm"> * The library code does not refer to |mem| pointer after this</span>
<span class="cm"> * function returns, so the application can safely free it.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_client_new3</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">**</span><span class="n">session_ptr</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">,</span>
                                <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span>
                                <span class="n">nghttp2_mem</span> <span class="o">*</span><span class="n">mem</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Like `nghttp2_session_server_new2()`, but with additional custom</span>
<span class="cm"> * memory allocator specified in the |mem|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |mem| can be ``NULL`` and the call is equivalent to</span>
<span class="cm"> * `nghttp2_session_server_new2()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership |mem|.  The application is</span>
<span class="cm"> * responsible for freeing |mem|.</span>
<span class="cm"> *</span>
<span class="cm"> * The library code does not refer to |mem| pointer after this</span>
<span class="cm"> * function returns, so the application can safely free it.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_server_new3</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">**</span><span class="n">session_ptr</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">,</span>
                                <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span>
                                <span class="n">nghttp2_mem</span> <span class="o">*</span><span class="n">mem</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Frees any resources allocated for |session|.  If |session| is</span>
<span class="cm"> * ``NULL``, this function does nothing.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_session_del</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sends pending frames to the remote peer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function retrieves the highest prioritized frame from the</span>
<span class="cm"> * outbound queue and sends it to the remote peer.  It does this as</span>
<span class="cm"> * many as possible until the user callback</span>
<span class="cm"> * :type:`nghttp2_send_callback` returns</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_WOULDBLOCK` or the outbound queue becomes empty.</span>
<span class="cm"> * This function calls several callback functions which are passed</span>
<span class="cm"> * when initializing the |session|.  Here is the simple time chart</span>
<span class="cm"> * which tells when each callback is invoked:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. Get the next frame to send from outbound queue.</span>
<span class="cm"> *</span>
<span class="cm"> * 2. Prepare transmission of the frame.</span>
<span class="cm"> *</span>
<span class="cm"> * 3. If the control frame cannot be sent because some preconditions</span>
<span class="cm"> *    are not met (e.g., request HEADERS cannot be sent after GOAWAY),</span>
<span class="cm"> *    :type:`nghttp2_on_frame_not_send_callback` is invoked.  Abort</span>
<span class="cm"> *    the following steps.</span>
<span class="cm"> *</span>
<span class="cm"> * 4. If the frame is HEADERS, PUSH_PROMISE or DATA,</span>
<span class="cm"> *    :type:`nghttp2_select_padding_callback` is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * 5. If the frame is request HEADERS, the stream is opened here.</span>
<span class="cm"> *</span>
<span class="cm"> * 6. :type:`nghttp2_before_frame_send_callback` is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * 7. :type:`nghttp2_send_callback` is invoked one or more times to</span>
<span class="cm"> *    send the frame.</span>
<span class="cm"> *</span>
<span class="cm"> * 8. :type:`nghttp2_on_frame_send_callback` is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * 9. If the transmission of the frame triggers closure of the stream,</span>
<span class="cm"> *    the stream is closed and</span>
<span class="cm"> *    :type:`nghttp2_on_stream_close_callback` is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`</span>
<span class="cm"> *     The callback function failed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_send</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the serialized data to send.</span>
<span class="cm"> *</span>
<span class="cm"> * This function behaves like `nghttp2_session_send()` except that it</span>
<span class="cm"> * does not use :type:`nghttp2_send_callback` to transmit data.</span>
<span class="cm"> * Instead, it assigns the pointer to the serialized data to the</span>
<span class="cm"> * |*data_ptr| and returns its length.  The other callbacks are called</span>
<span class="cm"> * in the same way as they are in `nghttp2_session_send()`.</span>
<span class="cm"> *</span>
<span class="cm"> * If no data is available to send, this function returns 0.</span>
<span class="cm"> *</span>
<span class="cm"> * This function may not return all serialized data in one invocation.</span>
<span class="cm"> * To get all data, call this function repeatedly until it returns 0</span>
<span class="cm"> * or one of negative error codes.</span>
<span class="cm"> *</span>
<span class="cm"> * The assigned |*data_ptr| is valid until the next call of</span>
<span class="cm"> * `nghttp2_session_mem_send()` or `nghttp2_session_send()`.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must send all data before sending the next chunk of</span>
<span class="cm"> * data.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the length of the data pointed by the</span>
<span class="cm"> * |*data_ptr| if it succeeds, or one of the following negative error</span>
<span class="cm"> * codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nghttp2_session_mem_send</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">**</span><span class="n">data_ptr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Receives frames from the remote peer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function receives as many frames as possible until the user</span>
<span class="cm"> * callback :type:`nghttp2_recv_callback` returns</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_WOULDBLOCK`.  This function calls several</span>
<span class="cm"> * callback functions which are passed when initializing the</span>
<span class="cm"> * |session|.  Here is the simple time chart which tells when each</span>
<span class="cm"> * callback is invoked:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. :type:`nghttp2_recv_callback` is invoked one or more times to</span>
<span class="cm"> *    receive frame header.</span>
<span class="cm"> *</span>
<span class="cm"> * 2. When frame header is received,</span>
<span class="cm"> *    :type:`nghttp2_on_begin_frame_callback` is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * 3. If the frame is DATA frame:</span>
<span class="cm"> *</span>
<span class="cm"> *    1. :type:`nghttp2_recv_callback` is invoked to receive DATA</span>
<span class="cm"> *       payload. For each chunk of data,</span>
<span class="cm"> *       :type:`nghttp2_on_data_chunk_recv_callback` is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> *    2. If one DATA frame is completely received,</span>
<span class="cm"> *       :type:`nghttp2_on_frame_recv_callback` is invoked.  If the</span>
<span class="cm"> *       reception of the frame triggers the closure of the stream,</span>
<span class="cm"> *       :type:`nghttp2_on_stream_close_callback` is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * 4. If the frame is the control frame:</span>
<span class="cm"> *</span>
<span class="cm"> *    1. :type:`nghttp2_recv_callback` is invoked one or more times to</span>
<span class="cm"> *       receive whole frame.</span>
<span class="cm"> *</span>
<span class="cm"> *    2. If the received frame is valid, then following actions are</span>
<span class="cm"> *       taken.  If the frame is either HEADERS or PUSH_PROMISE,</span>
<span class="cm"> *       :type:`nghttp2_on_begin_headers_callback` is invoked.  Then</span>
<span class="cm"> *       :type:`nghttp2_on_header_callback` is invoked for each header</span>
<span class="cm"> *       name/value pair.  After all name/value pairs are emitted</span>
<span class="cm"> *       successfully, :type:`nghttp2_on_frame_recv_callback` is</span>
<span class="cm"> *       invoked.  For other frames,</span>
<span class="cm"> *       :type:`nghttp2_on_frame_recv_callback` is invoked.  If the</span>
<span class="cm"> *       reception of the frame triggers the closure of the stream,</span>
<span class="cm"> *       :type:`nghttp2_on_stream_close_callback` is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> *    3. If the received frame is unpacked but is interpreted as</span>
<span class="cm"> *       invalid, :type:`nghttp2_on_invalid_frame_recv_callback` is</span>
<span class="cm"> *       invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_EOF`</span>
<span class="cm"> *     The remote peer did shutdown on the connection.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`</span>
<span class="cm"> *     The callback function failed.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_BAD_PREFACE`</span>
<span class="cm"> *     Invalid client preface was detected.  This error only returns</span>
<span class="cm"> *     when |session| was configured as server and</span>
<span class="cm"> *     `nghttp2_option_set_recv_client_preface()` is used.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_recv</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Processes data |in| as an input from the remote endpoint.  The</span>
<span class="cm"> * |inlen| indicates the number of bytes in the |in|.</span>
<span class="cm"> *</span>
<span class="cm"> * This function behaves like `nghttp2_session_recv()` except that it</span>
<span class="cm"> * does not use :type:`nghttp2_recv_callback` to receive data; the</span>
<span class="cm"> * |in| is the only data for the invocation of this function.  If all</span>
<span class="cm"> * bytes are processed, this function returns.  The other callbacks</span>
<span class="cm"> * are called in the same way as they are in `nghttp2_session_recv()`.</span>
<span class="cm"> *</span>
<span class="cm"> * In the current implementation, this function always tries to</span>
<span class="cm"> * processes all input data unless either an error occurs or</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PAUSE` is returned from</span>
<span class="cm"> * :type:`nghttp2_on_header_callback` or</span>
<span class="cm"> * :type:`nghttp2_on_data_chunk_recv_callback`.  If</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PAUSE` is used, the return value includes the</span>
<span class="cm"> * number of bytes which was used to produce the data or frame for the</span>
<span class="cm"> * callback.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of processed bytes, or one of the</span>
<span class="cm"> * following negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`</span>
<span class="cm"> *     The callback function failed.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_BAD_PREFACE`</span>
<span class="cm"> *     Invalid client preface was detected.  This error only returns</span>
<span class="cm"> *     when |session| was configured as server and</span>
<span class="cm"> *     `nghttp2_option_set_recv_client_preface()` is used.</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nghttp2_session_mem_recv</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
                                 <span class="kt">size_t</span> <span class="n">inlen</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Puts back previously deferred DATA frame in the stream |stream_id|</span>
<span class="cm"> * to the outbound queue.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The stream does not exist; or no deferred data exist.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_resume_data</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero value if |session| wants to receive data from the</span>
<span class="cm"> * remote peer.</span>
<span class="cm"> *</span>
<span class="cm"> * If both `nghttp2_session_want_read()` and</span>
<span class="cm"> * `nghttp2_session_want_write()` return 0, the application should</span>
<span class="cm"> * drop the connection.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_want_read</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero value if |session| wants to send data to the remote</span>
<span class="cm"> * peer.</span>
<span class="cm"> *</span>
<span class="cm"> * If both `nghttp2_session_want_read()` and</span>
<span class="cm"> * `nghttp2_session_want_write()` return 0, the application should</span>
<span class="cm"> * drop the connection.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_want_write</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns stream_user_data for the stream |stream_id|.  The</span>
<span class="cm"> * stream_user_data is provided by `nghttp2_submit_request()`,</span>
<span class="cm"> * `nghttp2_submit_headers()` or</span>
<span class="cm"> * `nghttp2_session_set_stream_user_data()`.  Unless it is set using</span>
<span class="cm"> * `nghttp2_session_set_stream_user_data()`, if the stream is</span>
<span class="cm"> * initiated by the remote endpoint, stream_user_data is always</span>
<span class="cm"> * ``NULL``.  If the stream does not exist, this function returns</span>
<span class="cm"> * ``NULL``.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">nghttp2_session_get_stream_user_data</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                           <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the |stream_user_data| to the stream denoted by the</span>
<span class="cm"> * |stream_id|.  If a stream user data is already set to the stream,</span>
<span class="cm"> * it is replaced with the |stream_user_data|.  It is valid to specify</span>
<span class="cm"> * ``NULL`` in the |stream_user_data|, which nullifies the associated</span>
<span class="cm"> * data pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * It is valid to set the |stream_user_data| to the stream reserved by</span>
<span class="cm"> * PUSH_PROMISE frame.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The stream does not exist</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_set_stream_user_data</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                         <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                         <span class="kt">void</span> <span class="o">*</span><span class="n">stream_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of frames in the outbound queue.  This does not</span>
<span class="cm"> * include the deferred DATA frames.</span>
<span class="cm"> */</span>
<span class="kt">size_t</span> <span class="nf">nghttp2_session_get_outbound_queue_size</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of DATA payload in bytes received without</span>
<span class="cm"> * WINDOW_UPDATE transmission for the stream |stream_id|.  The local</span>
<span class="cm"> * (receive) window size can be adjusted by</span>
<span class="cm"> * `nghttp2_submit_window_update()`.  This function takes into account</span>
<span class="cm"> * that and returns effective data length.  In particular, if the</span>
<span class="cm"> * local window size is reduced by submitting negative</span>
<span class="cm"> * window_size_increment with `nghttp2_submit_window_update()`, this</span>
<span class="cm"> * function returns the number of bytes less than actually received.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if it fails.</span>
<span class="cm"> */</span>
<span class="kt">int32_t</span>
<span class="nf">nghttp2_session_get_stream_effective_recv_data_length</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                      <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the local (receive) window size for the stream |stream_id|.</span>
<span class="cm"> * The local window size can be adjusted by</span>
<span class="cm"> * `nghttp2_submit_window_update()`.  This function takes into account</span>
<span class="cm"> * that and returns effective window size.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if it fails.</span>
<span class="cm"> */</span>
<span class="kt">int32_t</span>
<span class="nf">nghttp2_session_get_stream_effective_local_window_size</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                       <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of DATA payload in bytes received without</span>
<span class="cm"> * WINDOW_UPDATE transmission for a connection.  The local (receive)</span>
<span class="cm"> * window size can be adjusted by `nghttp2_submit_window_update()`.</span>
<span class="cm"> * This function takes into account that and returns effective data</span>
<span class="cm"> * length.  In particular, if the local window size is reduced by</span>
<span class="cm"> * submitting negative window_size_increment with</span>
<span class="cm"> * `nghttp2_submit_window_update()`, this function returns the number</span>
<span class="cm"> * of bytes less than actually received.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if it fails.</span>
<span class="cm"> */</span>
<span class="kt">int32_t</span>
<span class="nf">nghttp2_session_get_effective_recv_data_length</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the local (receive) window size for a connection.  The</span>
<span class="cm"> * local window size can be adjusted by</span>
<span class="cm"> * `nghttp2_submit_window_update()`.  This function takes into account</span>
<span class="cm"> * that and returns effective window size.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if it fails.</span>
<span class="cm"> */</span>
<span class="kt">int32_t</span>
<span class="nf">nghttp2_session_get_effective_local_window_size</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the remote window size for a given stream |stream_id|.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the amount of flow-controlled payload (e.g., DATA) that the</span>
<span class="cm"> * local endpoint can send without stream level WINDOW_UPDATE.  There</span>
<span class="cm"> * is also connection level flow control, so the effective size of</span>
<span class="cm"> * payload that the local endpoint can actually send is</span>
<span class="cm"> * min(`nghttp2_session_get_stream_remote_window_size()`,</span>
<span class="cm"> * `nghttp2_session_get_remote_window_size()`).</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if it fails.</span>
<span class="cm"> */</span>
<span class="kt">int32_t</span> <span class="nf">nghttp2_session_get_stream_remote_window_size</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                      <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the remote window size for a connection.</span>
<span class="cm"> *</span>
<span class="cm"> * This function always succeeds.</span>
<span class="cm"> */</span>
<span class="kt">int32_t</span> <span class="nf">nghttp2_session_get_remote_window_size</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if local peer half closed the given stream |stream_id|.</span>
<span class="cm"> * Returns 0 if it did not.  Returns -1 if no such stream exists.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_get_stream_local_close</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                           <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if remote peer half closed the given stream |stream_id|.</span>
<span class="cm"> * Returns 0 if it did not.  Returns -1 if no such stream exists.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_get_stream_remote_close</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                            <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Signals the session so that the connection should be terminated.</span>
<span class="cm"> *</span>
<span class="cm"> * The last stream ID is the minimum value between the stream ID of a</span>
<span class="cm"> * stream for which :type:`nghttp2_on_frame_recv_callback` was called</span>
<span class="cm"> * most recently and the last stream ID we have sent to the peer</span>
<span class="cm"> * previously.</span>
<span class="cm"> *</span>
<span class="cm"> * The |error_code| is the error code of this GOAWAY frame.  The</span>
<span class="cm"> * pre-defined error code is one of :enum:`nghttp2_error_code`.</span>
<span class="cm"> *</span>
<span class="cm"> * After the transmission, both `nghttp2_session_want_read()` and</span>
<span class="cm"> * `nghttp2_session_want_write()` return 0.</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be called when the connection should be</span>
<span class="cm"> * terminated after sending GOAWAY.  If the remaining streams should</span>
<span class="cm"> * be processed after GOAWAY, use `nghttp2_submit_goaway()` instead.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_terminate_session</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                      <span class="kt">uint32_t</span> <span class="n">error_code</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Signals the session so that the connection should be terminated.</span>
<span class="cm"> *</span>
<span class="cm"> * This function behaves like `nghttp2_session_terminate_session()`,</span>
<span class="cm"> * but the last stream ID can be specified by the application for fine</span>
<span class="cm"> * grained control of stream.  The HTTP/2 specification does not allow</span>
<span class="cm"> * last_stream_id to be increased.  So the actual value sent as</span>
<span class="cm"> * last_stream_id is the minimum value between the given</span>
<span class="cm"> * |last_stream_id| and the last_stream_id we have previously sent to</span>
<span class="cm"> * the peer.</span>
<span class="cm"> *</span>
<span class="cm"> * The |last_stream_id| is peer&#39;s stream ID or 0.  So if |session| is</span>
<span class="cm"> * initialized as client, |last_stream_id| must be even or 0.  If</span>
<span class="cm"> * |session| is initialized as server, |last_stream_id| must be odd or</span>
<span class="cm"> * 0.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |last_stream_id| is invalid.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_terminate_session2</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                       <span class="kt">int32_t</span> <span class="n">last_stream_id</span><span class="p">,</span>
                                       <span class="kt">uint32_t</span> <span class="n">error_code</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Signals to the client that the server started graceful shutdown</span>
<span class="cm"> * procedure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is only usable for server.  If this function is</span>
<span class="cm"> * called with client side session, this function returns</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_STATE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To gracefully shutdown HTTP/2 session, server should call this</span>
<span class="cm"> * function to send GOAWAY with last_stream_id (1u &lt;&lt; 31) - 1.  And</span>
<span class="cm"> * after some delay (e.g., 1 RTT), send another GOAWAY with the stream</span>
<span class="cm"> * ID that the server has some processing using</span>
<span class="cm"> * `nghttp2_submit_goaway()`.  See also</span>
<span class="cm"> * `nghttp2_session_get_last_proc_stream_id()`.</span>
<span class="cm"> *</span>
<span class="cm"> * Unlike `nghttp2_submit_goaway()`, this function just sends GOAWAY</span>
<span class="cm"> * and does nothing more.  This is a mere indication to the client</span>
<span class="cm"> * that session shutdown is imminent.  The application should call</span>
<span class="cm"> * `nghttp2_submit_goaway()` with appropriate last_stream_id after</span>
<span class="cm"> * this call.</span>
<span class="cm"> *</span>
<span class="cm"> * If one or more GOAWAY frame have been already sent by either</span>
<span class="cm"> * `nghttp2_submit_goaway()` or `nghttp2_session_terminate_session()`,</span>
<span class="cm"> * this function has no effect.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_STATE`</span>
<span class="cm"> *     The |session| is initialized as client.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_shutdown_notice</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the value of SETTINGS |id| notified by a remote endpoint.</span>
<span class="cm"> * The |id| must be one of values defined in</span>
<span class="cm"> * :enum:`nghttp2_settings_id`.</span>
<span class="cm"> */</span>
<span class="kt">uint32_t</span> <span class="nf">nghttp2_session_get_remote_settings</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                             <span class="n">nghttp2_settings_id</span> <span class="n">id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Tells the |session| that next stream ID is |next_stream_id|.  The</span>
<span class="cm"> * |next_stream_id| must be equal or greater than the value returned</span>
<span class="cm"> * by `nghttp2_session_get_next_stream_id()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |next_stream_id| is strictly less than the value</span>
<span class="cm"> *     `nghttp2_session_get_next_stream_id()` returns.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_set_next_stream_id</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                       <span class="kt">int32_t</span> <span class="n">next_stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the next outgoing stream ID.  Notice that return type is</span>
<span class="cm"> * uint32_t.  If we run out of stream ID for this session, this</span>
<span class="cm"> * function returns 1 &lt;&lt; 31.</span>
<span class="cm"> */</span>
<span class="kt">uint32_t</span> <span class="nf">nghttp2_session_get_next_stream_id</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Tells the |session| that |size| bytes for a stream denoted by</span>
<span class="cm"> * |stream_id| were consumed by application and are ready to</span>
<span class="cm"> * WINDOW_UPDATE.  This function is intended to be used without</span>
<span class="cm"> * automatic window update (see</span>
<span class="cm"> * `nghttp2_option_set_no_auto_window_update()`).</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |stream_id| is 0.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_STATE`</span>
<span class="cm"> *     Automatic WINDOW_UPDATE is not disabled.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_consume</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                            <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Performs post-process of HTTP Upgrade request.  This function can</span>
<span class="cm"> * be called from both client and server, but the behavior is very</span>
<span class="cm"> * different in each other.</span>
<span class="cm"> *</span>
<span class="cm"> * If called from client side, the |settings_payload| must be the</span>
<span class="cm"> * value sent in ``HTTP2-Settings`` header field and must be decoded</span>
<span class="cm"> * by base64url decoder.  The |settings_payloadlen| is the length of</span>
<span class="cm"> * |settings_payload|.  The |settings_payload| is unpacked and its</span>
<span class="cm"> * setting values will be submitted using `nghttp2_submit_settings()`.</span>
<span class="cm"> * This means that the client application code does not need to submit</span>
<span class="cm"> * SETTINGS by itself.  The stream with stream ID=1 is opened and the</span>
<span class="cm"> * |stream_user_data| is used for its stream_user_data.  The opened</span>
<span class="cm"> * stream becomes half-closed (local) state.</span>
<span class="cm"> *</span>
<span class="cm"> * If called from server side, the |settings_payload| must be the</span>
<span class="cm"> * value received in ``HTTP2-Settings`` header field and must be</span>
<span class="cm"> * decoded by base64url decoder.  The |settings_payloadlen| is the</span>
<span class="cm"> * length of |settings_payload|.  It is treated as if the SETTINGS</span>
<span class="cm"> * frame with that payload is received.  Thus, callback functions for</span>
<span class="cm"> * the reception of SETTINGS frame will be invoked.  The stream with</span>
<span class="cm"> * stream ID=1 is opened.  The |stream_user_data| is ignored.  The</span>
<span class="cm"> * opened stream becomes half-closed (remote).</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |settings_payload| is badly formed.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PROTO`</span>
<span class="cm"> *     The stream ID 1 is already used or closed; or is not available.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_upgrade</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                            <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">settings_payload</span><span class="p">,</span>
                            <span class="kt">size_t</span> <span class="n">settings_payloadlen</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">stream_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Serializes the SETTINGS values |iv| in the |buf|.  The size of the</span>
<span class="cm"> * |buf| is specified by |buflen|.  The number of entries in the |iv|</span>
<span class="cm"> * array is given by |niv|.  The required space in |buf| for the |niv|</span>
<span class="cm"> * entries is ``8*niv`` bytes and if the given buffer is too small, an</span>
<span class="cm"> * error is returned.  This function is used mainly for creating a</span>
<span class="cm"> * SETTINGS payload to be sent with the ``HTTP2-Settings`` header</span>
<span class="cm"> * field in an HTTP Upgrade request.  The data written in |buf| is NOT</span>
<span class="cm"> * base64url encoded and the application is responsible for encoding.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of bytes written in |buf|, or one</span>
<span class="cm"> * of the following negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |iv| contains duplicate settings ID or invalid value.</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`</span>
<span class="cm"> *     The provided |buflen| size is too small to hold the output.</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nghttp2_pack_settings_payload</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buflen</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">nghttp2_settings_entry</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span>
                                      <span class="kt">size_t</span> <span class="n">niv</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns string describing the |lib_error_code|.  The</span>
<span class="cm"> * |lib_error_code| must be one of the :enum:`nghttp2_error`.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">nghttp2_strerror</span><span class="p">(</span><span class="kt">int</span> <span class="n">lib_error_code</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |pri_spec| with the |stream_id| of the stream to depend</span>
<span class="cm"> * on with |weight| and its exclusive flag.  If |exclusive| is</span>
<span class="cm"> * nonzero, exclusive flag is set.</span>
<span class="cm"> *</span>
<span class="cm"> * The |weight| must be in [:enum:`NGHTTP2_MIN_WEIGHT`,</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_priority_spec_init</span><span class="p">(</span><span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">,</span>
                                <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">weight</span><span class="p">,</span>
                                <span class="kt">int</span> <span class="n">exclusive</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |pri_spec| with the default values.  The default values</span>
<span class="cm"> * are: stream_id = 0, weight = :macro:`NGHTTP2_DEFAULT_WEIGHT` and</span>
<span class="cm"> * exclusive = 0.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_priority_spec_default_init</span><span class="p">(</span><span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero if the |pri_spec| is filled with default values.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_priority_spec_check_default</span><span class="p">(</span><span class="k">const</span> <span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits HEADERS frame and optionally one or more DATA frames.</span>
<span class="cm"> *</span>
<span class="cm"> * The |pri_spec| is priority specification of this request.  ``NULL``</span>
<span class="cm"> * means the default priority (see</span>
<span class="cm"> * `nghttp2_priority_spec_default_init()`).  To specify the priority,</span>
<span class="cm"> * use `nghttp2_priority_spec_init()`.  If |pri_spec| is not ``NULL``,</span>
<span class="cm"> * this function will copy its data members.</span>
<span class="cm"> *</span>
<span class="cm"> * The `pri_spec-&gt;weight` must be in [:enum:`NGHTTP2_MIN_WEIGHT`,</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.  If `pri_spec-&gt;weight` is</span>
<span class="cm"> * strictly less than :enum:`NGHTTP2_MIN_WEIGHT`, it becomes</span>
<span class="cm"> * :enum:`NGHTTP2_MIN_WEIGHT`.  If it is strictly greater than</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`, it becomes :enum:`NGHTTP2_MAX_WEIGHT`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |nva| is an array of name/value pair :type:`nghttp2_nv` with</span>
<span class="cm"> * |nvlen| elements.  The application is responsible to include</span>
<span class="cm"> * required pseudo-header fields (header field whose name starts with</span>
<span class="cm"> * &quot;:&quot;) in |nva| and must place pseudo-headers before regular header</span>
<span class="cm"> * fields.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates copies of all name/value pairs in |nva|.  It</span>
<span class="cm"> * also lower-cases all names in |nva|.  The order of elements in</span>
<span class="cm"> * |nva| is preserved.</span>
<span class="cm"> *</span>
<span class="cm"> * HTTP/2 specification has requirement about header fields in the</span>
<span class="cm"> * request HEADERS.  See the specification for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * If |data_prd| is not ``NULL``, it provides data which will be sent</span>
<span class="cm"> * in subsequent DATA frames.  In this case, a method that allows</span>
<span class="cm"> * request message bodies</span>
<span class="cm"> * (http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9) must</span>
<span class="cm"> * be specified with ``:method`` key in |nva| (e.g. ``POST``).  This</span>
<span class="cm"> * function does not take ownership of the |data_prd|.  The function</span>
<span class="cm"> * copies the members of the |data_prd|.  If |data_prd| is ``NULL``,</span>
<span class="cm"> * HEADERS have END_STREAM set.  The |stream_user_data| is data</span>
<span class="cm"> * associated to the stream opened by this request and can be an</span>
<span class="cm"> * arbitrary pointer, which can be retrieved later by</span>
<span class="cm"> * `nghttp2_session_get_stream_user_data()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns assigned stream ID if it succeeds, or one of</span>
<span class="cm"> * the following negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE`</span>
<span class="cm"> *     No stream ID is available because maximum stream ID was</span>
<span class="cm"> *     reached.</span>
<span class="cm"> *</span>
<span class="cm"> * .. warning::</span>
<span class="cm"> *</span>
<span class="cm"> *   This function returns assigned stream ID if it succeeds.  But</span>
<span class="cm"> *   that stream is not opened yet.  The application must not submit</span>
<span class="cm"> *   frame to that stream ID before</span>
<span class="cm"> *   :type:`nghttp2_before_frame_send_callback` is called for this</span>
<span class="cm"> *   frame.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int32_t</span> <span class="nf">nghttp2_submit_request</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">nghttp2_data_provider</span> <span class="o">*</span><span class="n">data_prd</span><span class="p">,</span>
                               <span class="kt">void</span> <span class="o">*</span><span class="n">stream_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits response HEADERS frame and optionally one or more DATA</span>
<span class="cm"> * frames against the stream |stream_id|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |nva| is an array of name/value pair :type:`nghttp2_nv` with</span>
<span class="cm"> * |nvlen| elements.  The application is responsible to include</span>
<span class="cm"> * required pseudo-header fields (header field whose name starts with</span>
<span class="cm"> * &quot;:&quot;) in |nva| and must place pseudo-headers before regular header</span>
<span class="cm"> * fields.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates copies of all name/value pairs in |nva|.  It</span>
<span class="cm"> * also lower-cases all names in |nva|.  The order of elements in</span>
<span class="cm"> * |nva| is preserved.</span>
<span class="cm"> *</span>
<span class="cm"> * HTTP/2 specification has requirement about header fields in the</span>
<span class="cm"> * response HEADERS.  See the specification for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * If |data_prd| is not ``NULL``, it provides data which will be sent</span>
<span class="cm"> * in subsequent DATA frames.  This function does not take ownership</span>
<span class="cm"> * of the |data_prd|.  The function copies the members of the</span>
<span class="cm"> * |data_prd|.  If |data_prd| is ``NULL``, HEADERS will have</span>
<span class="cm"> * END_STREAM flag set.</span>
<span class="cm"> *</span>
<span class="cm"> * This method can be used as normal HTTP response and push response.</span>
<span class="cm"> * When pushing a resource using this function, the |session| must be</span>
<span class="cm"> * configured using `nghttp2_session_server_new()` or its variants and</span>
<span class="cm"> * the target stream denoted by the |stream_id| must be reserved using</span>
<span class="cm"> * `nghttp2_submit_push_promise()`.</span>
<span class="cm"> *</span>
<span class="cm"> * To send non-final response headers (e.g., HTTP status 101), don&#39;t</span>
<span class="cm"> * use this function because this function half-closes the outbound</span>
<span class="cm"> * stream.  Instead, use `nghttp2_submit_headers()` for this purpose.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |stream_id| is 0.</span>
<span class="cm"> *</span>
<span class="cm"> * .. warning::</span>
<span class="cm"> *</span>
<span class="cm"> *   Calling this function twice for the same stream ID may lead to</span>
<span class="cm"> *   program crash.  It is generally considered to a programming error</span>
<span class="cm"> *   to commit response twice.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_response</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">nghttp2_data_provider</span> <span class="o">*</span><span class="n">data_prd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits trailer HEADERS against the stream |stream_id|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |nva| is an array of name/value pair :type:`nghttp2_nv` with</span>
<span class="cm"> * |nvlen| elements.  The application is responsible not to include</span>
<span class="cm"> * required pseudo-header fields (header field whose name starts with</span>
<span class="cm"> * &quot;:&quot;) in |nva|.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates copies of all name/value pairs in |nva|.  It</span>
<span class="cm"> * also lower-cases all names in |nva|.  The order of elements in</span>
<span class="cm"> * |nva| is preserved.</span>
<span class="cm"> *</span>
<span class="cm"> * For server, trailer must be followed by response HEADERS or</span>
<span class="cm"> * response DATA.  The library does not check that response HEADERS</span>
<span class="cm"> * has already sent and if `nghttp2_submit_trailer()` is called before</span>
<span class="cm"> * any response HEADERS submission (usually by</span>
<span class="cm"> * `nghttp2_submit_response()`), the content of |nva| will be sent as</span>
<span class="cm"> * reponse headers, which will result in error.</span>
<span class="cm"> *</span>
<span class="cm"> * This function has the same effect with `nghttp2_submit_headers()`,</span>
<span class="cm"> * with flags = :enum:`NGHTTP2_FLAG_END_HEADERS` and both pri_spec and</span>
<span class="cm"> * stream_user_data to NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * To submit trailer after `nghttp2_submit_response()` is called, the</span>
<span class="cm"> * application has to specify :type:`nghttp2_data_provider` to</span>
<span class="cm"> * `nghttp2_submit_response()`.  In side</span>
<span class="cm"> * :type:`nghttp2_data_source_read_callback`, when setting</span>
<span class="cm"> * :enum:`NGHTTP2_DATA_FLAG_EOF`, also set</span>
<span class="cm"> * :enum:`NGHTTP2_DATA_FLAG_NO_END_STREAM`.  After that, the</span>
<span class="cm"> * application can send trailer using `nghttp2_submit_trailer()`.</span>
<span class="cm"> * `nghttp2_submit_trailer()` can be used inside</span>
<span class="cm"> * :type:`nghttp2_data_source_read_callback`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds and |stream_id| is -1.</span>
<span class="cm"> * Otherwise, this function returns 0 if it succeeds, or one of the</span>
<span class="cm"> * following negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |stream_id| is 0.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_trailer</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits HEADERS frame. The |flags| is bitwise OR of the</span>
<span class="cm"> * following values:</span>
<span class="cm"> *</span>
<span class="cm"> * * :enum:`NGHTTP2_FLAG_END_STREAM`</span>
<span class="cm"> *</span>
<span class="cm"> * If |flags| includes :enum:`NGHTTP2_FLAG_END_STREAM`, this frame has</span>
<span class="cm"> * END_STREAM flag set.</span>
<span class="cm"> *</span>
<span class="cm"> * The library handles the CONTINUATION frame internally and it</span>
<span class="cm"> * correctly sets END_HEADERS to the last sequence of the PUSH_PROMISE</span>
<span class="cm"> * or CONTINUATION frame.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |stream_id| is -1, this frame is assumed as request (i.e.,</span>
<span class="cm"> * request HEADERS frame which opens new stream).  In this case, the</span>
<span class="cm"> * assigned stream ID will be returned.  Otherwise, specify stream ID</span>
<span class="cm"> * in |stream_id|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |pri_spec| is priority specification of this request.  ``NULL``</span>
<span class="cm"> * means the default priority (see</span>
<span class="cm"> * `nghttp2_priority_spec_default_init()`).  To specify the priority,</span>
<span class="cm"> * use `nghttp2_priority_spec_init()`.  If |pri_spec| is not ``NULL``,</span>
<span class="cm"> * this function will copy its data members.</span>
<span class="cm"> *</span>
<span class="cm"> * The `pri_spec-&gt;weight` must be in [:enum:`NGHTTP2_MIN_WEIGHT`,</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.  If `pri_spec-&gt;weight` is</span>
<span class="cm"> * strictly less than :enum:`NGHTTP2_MIN_WEIGHT`, it becomes</span>
<span class="cm"> * :enum:`NGHTTP2_MIN_WEIGHT`.  If it is strictly greater than</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`, it becomes :enum:`NGHTTP2_MAX_WEIGHT`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |nva| is an array of name/value pair :type:`nghttp2_nv` with</span>
<span class="cm"> * |nvlen| elements.  The application is responsible to include</span>
<span class="cm"> * required pseudo-header fields (header field whose name starts with</span>
<span class="cm"> * &quot;:&quot;) in |nva| and must place pseudo-headers before regular header</span>
<span class="cm"> * fields.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates copies of all name/value pairs in |nva|.  It</span>
<span class="cm"> * also lower-cases all names in |nva|.  The order of elements in</span>
<span class="cm"> * |nva| is preserved.</span>
<span class="cm"> *</span>
<span class="cm"> * The |stream_user_data| is a pointer to an arbitrary data which is</span>
<span class="cm"> * associated to the stream this frame will open.  Therefore it is</span>
<span class="cm"> * only used if this frame opens streams, in other words, it changes</span>
<span class="cm"> * stream state from idle or reserved to open.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is low-level in a sense that the application code can</span>
<span class="cm"> * specify flags directly.  For usual HTTP request,</span>
<span class="cm"> * `nghttp2_submit_request()` is useful.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns newly assigned stream ID if it succeeds and</span>
<span class="cm"> * |stream_id| is -1.  Otherwise, this function returns 0 if it</span>
<span class="cm"> * succeeds, or one of the following negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE`</span>
<span class="cm"> *     No stream ID is available because maximum stream ID was</span>
<span class="cm"> *     reached.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |stream_id| is 0.</span>
<span class="cm"> *</span>
<span class="cm"> * .. warning::</span>
<span class="cm"> *</span>
<span class="cm"> *   This function returns assigned stream ID if it succeeds and</span>
<span class="cm"> *   |stream_id| is -1.  But that stream is not opened yet.  The</span>
<span class="cm"> *   application must not submit frame to that stream ID before</span>
<span class="cm"> *   :type:`nghttp2_before_frame_send_callback` is called for this</span>
<span class="cm"> *   frame.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int32_t</span> <span class="nf">nghttp2_submit_headers</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                               <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">,</span>
                               <span class="kt">void</span> <span class="o">*</span><span class="n">stream_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits one or more DATA frames to the stream |stream_id|.  The</span>
<span class="cm"> * data to be sent are provided by |data_prd|.  If |flags| contains</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_END_STREAM`, the last DATA frame has END_STREAM</span>
<span class="cm"> * flag set.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership of the |data_prd|.  The</span>
<span class="cm"> * function copies the members of the |data_prd|.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_DATA_EXIST`</span>
<span class="cm"> *     DATA has been already submitted and not fully processed yet.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |stream_id| is 0.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_STREAM_CLOSED`</span>
<span class="cm"> *     The stream was alreay closed; or the |stream_id| is invalid.</span>
<span class="cm"> *</span>
<span class="cm"> * .. note::</span>
<span class="cm"> *</span>
<span class="cm"> *   Currently, only one data is allowed for a stream at a time.</span>
<span class="cm"> *   Submitting data more than once before first data is finished</span>
<span class="cm"> *   results in :enum:`NGHTTP2_ERR_DATA_EXIST` error code.  The</span>
<span class="cm"> *   earliest callback which tells that previous data is done is</span>
<span class="cm"> *   :type:`nghttp2_on_frame_send_callback`.  In side that callback,</span>
<span class="cm"> *   new data can be submitted using `nghttp2_submit_data()`.  Of</span>
<span class="cm"> *   course, all data except for last one must not have</span>
<span class="cm"> *   :enum:`NGHTTP2_FLAG_END_STREAM` flag set in |flags|.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_data</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                        <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">nghttp2_data_provider</span> <span class="o">*</span><span class="n">data_prd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits PRIORITY frame to change the priority of stream |stream_id|</span>
<span class="cm"> * to the priority specification |pri_spec|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |pri_spec| is priority specification of this request.  ``NULL``</span>
<span class="cm"> * is not allowed for this function. To specify the priority, use</span>
<span class="cm"> * `nghttp2_priority_spec_init()`.  This function will copy its data</span>
<span class="cm"> * members.</span>
<span class="cm"> *</span>
<span class="cm"> * The `pri_spec-&gt;weight` must be in [:enum:`NGHTTP2_MIN_WEIGHT`,</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.  If `pri_spec-&gt;weight` is</span>
<span class="cm"> * strictly less than :enum:`NGHTTP2_MIN_WEIGHT`, it becomes</span>
<span class="cm"> * :enum:`NGHTTP2_MIN_WEIGHT`.  If it is strictly greater than</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`, it becomes :enum:`NGHTTP2_MAX_WEIGHT`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |stream_id| is 0; or the |pri_spec| is NULL; or trying to</span>
<span class="cm"> *     depend on itself.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_priority</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                            <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits RST_STREAM frame to cancel/reject the stream |stream_id|</span>
<span class="cm"> * with the error code |error_code|.</span>
<span class="cm"> *</span>
<span class="cm"> * The pre-defined error code is one of :enum:`nghttp2_error_code`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |stream_id| is 0.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_rst_stream</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                              <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">error_code</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Stores local settings and submits SETTINGS frame.  The |iv| is the</span>
<span class="cm"> * pointer to the array of :type:`nghttp2_settings_entry`.  The |niv|</span>
<span class="cm"> * indicates the number of :type:`nghttp2_settings_entry`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership of the |iv|.  This function</span>
<span class="cm"> * copies all the elements in the |iv|.</span>
<span class="cm"> *</span>
<span class="cm"> * While updating individual stream&#39;s local window size, if the window</span>
<span class="cm"> * size becomes strictly larger than NGHTTP2_MAX_WINDOW_SIZE,</span>
<span class="cm"> * RST_STREAM is issued against such a stream.</span>
<span class="cm"> *</span>
<span class="cm"> * SETTINGS with :enum:`NGHTTP2_FLAG_ACK` is automatically submitted</span>
<span class="cm"> * by the library and application could not send it at its will.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |iv| contains invalid value (e.g., initial window size</span>
<span class="cm"> *     strictly greater than (1 &lt;&lt; 31) - 1.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_TOO_MANY_INFLIGHT_SETTINGS`</span>
<span class="cm"> *     There is already another in-flight SETTINGS.  Note that the</span>
<span class="cm"> *     current implementation only allows 1 in-flight SETTINGS frame</span>
<span class="cm"> *     without ACK flag set.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_settings</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">nghttp2_settings_entry</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">niv</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits PUSH_PROMISE frame.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored.  The library handles the</span>
<span class="cm"> * CONTINUATION frame internally and it correctly sets END_HEADERS to</span>
<span class="cm"> * the last sequence of the PUSH_PROMISE or CONTINUATION frame.</span>
<span class="cm"> *</span>
<span class="cm"> * The |stream_id| must be client initiated stream ID.</span>
<span class="cm"> *</span>
<span class="cm"> * The |nva| is an array of name/value pair :type:`nghttp2_nv` with</span>
<span class="cm"> * |nvlen| elements.  The application is responsible to include</span>
<span class="cm"> * required pseudo-header fields (header field whose name starts with</span>
<span class="cm"> * &quot;:&quot;) in |nva| and must place pseudo-headers before regular header</span>
<span class="cm"> * fields.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates copies of all name/value pairs in |nva|.  It</span>
<span class="cm"> * also lower-cases all names in |nva|.  The order of elements in</span>
<span class="cm"> * |nva| is preserved.</span>
<span class="cm"> *</span>
<span class="cm"> * The |promised_stream_user_data| is a pointer to an arbitrary data</span>
<span class="cm"> * which is associated to the promised stream this frame will open and</span>
<span class="cm"> * make it in reserved state.  It is available using</span>
<span class="cm"> * `nghttp2_session_get_stream_user_data()`.  The application can</span>
<span class="cm"> * access it in :type:`nghttp2_before_frame_send_callback` and</span>
<span class="cm"> * :type:`nghttp2_on_frame_send_callback` of this frame.</span>
<span class="cm"> *</span>
<span class="cm"> * The client side is not allowed to use this function.</span>
<span class="cm"> *</span>
<span class="cm"> * To submit response headers and data, use</span>
<span class="cm"> * `nghttp2_submit_response()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns assigned promised stream ID if it succeeds,</span>
<span class="cm"> * or one of the following negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PROTO`</span>
<span class="cm"> *     This function was invoked when |session| is initialized as</span>
<span class="cm"> *     client.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE`</span>
<span class="cm"> *     No stream ID is available because maximum stream ID was</span>
<span class="cm"> *     reached.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |stream_id| is 0; The |stream_id| does not designate stream</span>
<span class="cm"> *     that peer initiated.</span>
<span class="cm"> *</span>
<span class="cm"> * .. warning::</span>
<span class="cm"> *</span>
<span class="cm"> *   This function returns assigned promised stream ID if it succeeds.</span>
<span class="cm"> *   But that stream is not opened yet.  The application must not</span>
<span class="cm"> *   submit frame to that stream ID before</span>
<span class="cm"> *   :type:`nghttp2_before_frame_send_callback` is called for this</span>
<span class="cm"> *   frame.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int32_t</span> <span class="nf">nghttp2_submit_push_promise</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                                    <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span>
                                    <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">,</span>
                                    <span class="kt">void</span> <span class="o">*</span><span class="n">promised_stream_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits PING frame.  You don&#39;t have to send PING back when you</span>
<span class="cm"> * received PING frame.  The library automatically submits PING frame</span>
<span class="cm"> * in this case.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |opaque_data| is non ``NULL``, then it should point to the 8</span>
<span class="cm"> * bytes array of memory to specify opaque data to send with PING</span>
<span class="cm"> * frame.  If the |opaque_data| is ``NULL``, zero-cleared 8 bytes will</span>
<span class="cm"> * be sent as opaque data.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_ping</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">opaque_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits GOAWAY frame with the last stream ID |last_stream_id| and</span>
<span class="cm"> * the error code |error_code|.</span>
<span class="cm"> *</span>
<span class="cm"> * The pre-defined error code is one of :enum:`nghttp2_error_code`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |last_stream_id| is peer&#39;s stream ID or 0.  So if |session| is</span>
<span class="cm"> * initialized as client, |last_stream_id| must be even or 0.  If</span>
<span class="cm"> * |session| is initialized as server, |last_stream_id| must be odd or</span>
<span class="cm"> * 0.</span>
<span class="cm"> *</span>
<span class="cm"> * The HTTP/2 specification says last_stream_id must not be increased</span>
<span class="cm"> * from the value previously sent.  So the actual value sent as</span>
<span class="cm"> * last_stream_id is the minimum value between the given</span>
<span class="cm"> * |last_stream_id| and the last_stream_id previously sent to the</span>
<span class="cm"> * peer.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |opaque_data| is not ``NULL`` and |opaque_data_len| is not</span>
<span class="cm"> * zero, those data will be sent as additional debug data.  The</span>
<span class="cm"> * library makes a copy of the memory region pointed by |opaque_data|</span>
<span class="cm"> * with the length |opaque_data_len|, so the caller does not need to</span>
<span class="cm"> * keep this memory after the return of this function.  If the</span>
<span class="cm"> * |opaque_data_len| is 0, the |opaque_data| could be ``NULL``.</span>
<span class="cm"> *</span>
<span class="cm"> * After successful transmission of GOAWAY, following things happen.</span>
<span class="cm"> * All incoming streams having strictly more than |last_stream_id| are</span>
<span class="cm"> * closed.  All incoming HEADERS which starts new stream are simply</span>
<span class="cm"> * ignored.  After all active streams are handled, both</span>
<span class="cm"> * `nghttp2_session_want_read()` and `nghttp2_session_want_write()`</span>
<span class="cm"> * return 0 and the application can close session.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |opaque_data_len| is too large; the |last_stream_id| is</span>
<span class="cm"> *     invalid.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_goaway</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                          <span class="kt">int32_t</span> <span class="n">last_stream_id</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">error_code</span><span class="p">,</span>
                          <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">opaque_data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">opaque_data_len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the last stream ID of a stream for which</span>
<span class="cm"> * :type:`nghttp2_on_frame_recv_callback` was invoked most recently.</span>
<span class="cm"> * The returned value can be used as last_stream_id parameter for</span>
<span class="cm"> * `nghttp2_submit_goaway()` and</span>
<span class="cm"> * `nghttp2_session_terminate_session2()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function always succeeds.</span>
<span class="cm"> */</span>
<span class="kt">int32_t</span> <span class="nf">nghttp2_session_get_last_proc_stream_id</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits WINDOW_UPDATE frame.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |window_size_increment| is positive, the WINDOW_UPDATE with</span>
<span class="cm"> * that value as window_size_increment is queued.  If the</span>
<span class="cm"> * |window_size_increment| is larger than the received bytes from the</span>
<span class="cm"> * remote endpoint, the local window size is increased by that</span>
<span class="cm"> * difference.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |window_size_increment| is negative, the local window size</span>
<span class="cm"> * is decreased by -|window_size_increment|.  If automatic</span>
<span class="cm"> * WINDOW_UPDATE is enabled</span>
<span class="cm"> * (`nghttp2_option_set_no_auto_window_update()`), and the library</span>
<span class="cm"> * decided that the WINDOW_UPDATE should be submitted, then</span>
<span class="cm"> * WINDOW_UPDATE is queued with the current received bytes count.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |window_size_increment| is 0, the function does nothing and</span>
<span class="cm"> * returns 0.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_FLOW_CONTROL`</span>
<span class="cm"> *     The local window size overflow or gets negative.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_window_update</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                                 <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                 <span class="kt">int32_t</span> <span class="n">window_size_increment</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * This function previously submits ALTSVC frame with given</span>
<span class="cm"> * parameters, but is deprecated and will be removed in a future</span>
<span class="cm"> * release.  This function does nothing and just return 0.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_altsvc</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                          <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">max_age</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">,</span>
                          <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">protocol_id</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">protocol_id_len</span><span class="p">,</span>
                          <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">host_len</span><span class="p">,</span>
                          <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">origin</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">origin_len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Compares ``lhs-&gt;name`` of length ``lhs-&gt;namelen`` bytes and</span>
<span class="cm"> * ``rhs-&gt;name`` of length ``rhs-&gt;namelen`` bytes.  Returns negative</span>
<span class="cm"> * integer if ``lhs-&gt;name`` is found to be less than ``rhs-&gt;name``; or</span>
<span class="cm"> * returns positive integer if ``lhs-&gt;name`` is found to be greater</span>
<span class="cm"> * than ``rhs-&gt;name``; or returns 0 otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_nv_compare_name</span><span class="p">(</span><span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">rhs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * A helper function for dealing with NPN in client side or ALPN in</span>
<span class="cm"> * server side.  The |in| contains peer&#39;s protocol list in preferable</span>
<span class="cm"> * order.  The format of |in| is length-prefixed and not</span>
<span class="cm"> * null-terminated.  For example, ``HTTP-draft-04/2.0`` and</span>
<span class="cm"> * ``http/1.1`` stored in |in| like this::</span>
<span class="cm"> *</span>
<span class="cm"> *     in[0] = 17</span>
<span class="cm"> *     in[1..17] = &quot;HTTP-draft-04/2.0&quot;</span>
<span class="cm"> *     in[18] = 8</span>
<span class="cm"> *     in[19..26] = &quot;http/1.1&quot;</span>
<span class="cm"> *     inlen = 27</span>
<span class="cm"> *</span>
<span class="cm"> * The selection algorithm is as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. If peer&#39;s list contains HTTP/2 protocol the library supports,</span>
<span class="cm"> *    it is selected and returns 1. The following step is not taken.</span>
<span class="cm"> *</span>
<span class="cm"> * 2. If peer&#39;s list contains ``http/1.1``, this function selects</span>
<span class="cm"> *    ``http/1.1`` and returns 0.  The following step is not taken.</span>
<span class="cm"> *</span>
<span class="cm"> * 3. This function selects nothing and returns -1 (So called</span>
<span class="cm"> *    non-overlap case).  In this case, |out| and |outlen| are left</span>
<span class="cm"> *    untouched.</span>
<span class="cm"> *</span>
<span class="cm"> * Selecting ``HTTP-draft-04/2.0`` means that ``HTTP-draft-04/2.0`` is</span>
<span class="cm"> * written into |*out| and its length (which is 17) is assigned to</span>
<span class="cm"> * |*outlen|.</span>
<span class="cm"> *</span>
<span class="cm"> * For ALPN, refer to</span>
<span class="cm"> * https://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg-05</span>
<span class="cm"> *</span>
<span class="cm"> * See http://technotes.googlecode.com/git/nextprotoneg.html for more</span>
<span class="cm"> * details about NPN.</span>
<span class="cm"> *</span>
<span class="cm"> * For NPN, to use this method you should do something like::</span>
<span class="cm"> *</span>
<span class="cm"> *     static int select_next_proto_cb(SSL* ssl,</span>
<span class="cm"> *                                     unsigned char **out,</span>
<span class="cm"> *                                     unsigned char *outlen,</span>
<span class="cm"> *                                     const unsigned char *in,</span>
<span class="cm"> *                                     unsigned int inlen,</span>
<span class="cm"> *                                     void *arg)</span>
<span class="cm"> *     {</span>
<span class="cm"> *         int rv;</span>
<span class="cm"> *         rv = nghttp2_select_next_protocol(out, outlen, in, inlen);</span>
<span class="cm"> *         if(rv == 1) {</span>
<span class="cm"> *             ((MyType*)arg)-&gt;http2_selected = 1;</span>
<span class="cm"> *         }</span>
<span class="cm"> *         return SSL_TLSEXT_ERR_OK;</span>
<span class="cm"> *     }</span>
<span class="cm"> *     ...</span>
<span class="cm"> *     SSL_CTX_set_next_proto_select_cb(ssl_ctx, select_next_proto_cb, my_obj);</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_select_next_protocol</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">out</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">outlen</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inlen</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to a nghttp2_info struct with version information</span>
<span class="cm"> * about the run-time library in use.  The |least_version| argument</span>
<span class="cm"> * can be set to a 24 bit numerical value for the least accepted</span>
<span class="cm"> * version number and if the condition is not met, this function will</span>
<span class="cm"> * return a ``NULL``.  Pass in 0 to skip the version checking.</span>
<span class="cm"> */</span>
<span class="n">nghttp2_info</span> <span class="o">*</span><span class="nf">nghttp2_version</span><span class="p">(</span><span class="kt">int</span> <span class="n">least_version</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero if the :type:`nghttp2_error` library error code</span>
<span class="cm"> * |lib_error| is fatal.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_is_fatal</span><span class="p">(</span><span class="kt">int</span> <span class="n">lib_error</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero if HTTP header field name |name| of length |len| is</span>
<span class="cm"> * valid according to http://tools.ietf.org/html/rfc7230#section-3.2</span>
<span class="cm"> *</span>
<span class="cm"> * Because this is a header field name in HTTP2, the upper cased alphabet</span>
<span class="cm"> * is treated as error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_check_header_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero if HTTP header field value |value| of length |len|</span>
<span class="cm"> * is valid according to</span>
<span class="cm"> * http://tools.ietf.org/html/rfc7230#section-3.2</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_check_header_value</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* HPACK API */</span>

<span class="k">struct</span> <span class="n">nghttp2_hd_deflater</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * HPACK deflater object.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">nghttp2_hd_deflater</span> <span class="n">nghttp2_hd_deflater</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |*deflater_ptr| for deflating name/values pairs.</span>
<span class="cm"> *</span>
<span class="cm"> * The |deflate_hd_table_bufsize_max| is the upper bound of header</span>
<span class="cm"> * table size the deflater will use.</span>
<span class="cm"> *</span>
<span class="cm"> * If this function fails, |*deflater_ptr| is left untouched.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_hd_deflate_new</span><span class="p">(</span><span class="n">nghttp2_hd_deflater</span> <span class="o">**</span><span class="n">deflater_ptr</span><span class="p">,</span>
                           <span class="kt">size_t</span> <span class="n">deflate_hd_table_bufsize_max</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Like `nghttp2_hd_deflate_new()`, but with additional custom memory</span>
<span class="cm"> * allocator specified in the |mem|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |mem| can be ``NULL`` and the call is equivalent to</span>
<span class="cm"> * `nghttp2_hd_deflate_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership |mem|.  The application is</span>
<span class="cm"> * responsible for freeing |mem|.</span>
<span class="cm"> *</span>
<span class="cm"> * The library code does not refer to |mem| pointer after this</span>
<span class="cm"> * function returns, so the application can safely free it.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_hd_deflate_new2</span><span class="p">(</span><span class="n">nghttp2_hd_deflater</span> <span class="o">**</span><span class="n">deflater_ptr</span><span class="p">,</span>
                            <span class="kt">size_t</span> <span class="n">deflate_hd_table_bufsize_max</span><span class="p">,</span>
                            <span class="n">nghttp2_mem</span> <span class="o">*</span><span class="n">mem</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Deallocates any resources allocated for |deflater|.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_hd_deflate_del</span><span class="p">(</span><span class="n">nghttp2_hd_deflater</span> <span class="o">*</span><span class="n">deflater</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Changes header table size of the |deflater| to</span>
<span class="cm"> * |settings_hd_table_bufsize_max| bytes.  This may trigger eviction</span>
<span class="cm"> * in the dynamic table.</span>
<span class="cm"> *</span>
<span class="cm"> * The |settings_hd_table_bufsize_max| should be the value received in</span>
<span class="cm"> * SETTINGS_HEADER_TABLE_SIZE.</span>
<span class="cm"> *</span>
<span class="cm"> * The deflater never uses more memory than</span>
<span class="cm"> * ``deflate_hd_table_bufsize_max`` bytes specified in</span>
<span class="cm"> * `nghttp2_hd_deflate_new()`.  Therefore, if</span>
<span class="cm"> * |settings_hd_table_bufsize_max| &gt; ``deflate_hd_table_bufsize_max``,</span>
<span class="cm"> * resulting maximum table size becomes</span>
<span class="cm"> * ``deflate_hd_table_bufsize_max``.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_hd_deflate_change_table_size</span><span class="p">(</span><span class="n">nghttp2_hd_deflater</span> <span class="o">*</span><span class="n">deflater</span><span class="p">,</span>
                                         <span class="kt">size_t</span> <span class="n">settings_hd_table_bufsize_max</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Deflates the |nva|, which has the |nvlen| name/value pairs, into</span>
<span class="cm"> * the |buf| of length |buflen|.</span>
<span class="cm"> *</span>
<span class="cm"> * If |buf| is not large enough to store the deflated header block,</span>
<span class="cm"> * this function fails with :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`.  The</span>
<span class="cm"> * caller should use `nghttp2_hd_deflate_bound()` to know the upper</span>
<span class="cm"> * bound of buffer size required to deflate given header name/value</span>
<span class="cm"> * pairs.</span>
<span class="cm"> *</span>
<span class="cm"> * Once this function fails, subsequent call of this function always</span>
<span class="cm"> * returns :enum:`NGHTTP2_ERR_HEADER_COMP`.</span>
<span class="cm"> *</span>
<span class="cm"> * After this function returns, it is safe to delete the |nva|.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_HEADER_COMP`</span>
<span class="cm"> *     Deflation process has failed.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`</span>
<span class="cm"> *     The provided |buflen| size is too small to hold the output.</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nghttp2_hd_deflate_hd</span><span class="p">(</span><span class="n">nghttp2_hd_deflater</span> <span class="o">*</span><span class="n">deflater</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
                              <span class="kt">size_t</span> <span class="n">buflen</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span>
                              <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns an upper bound on the compressed size after deflation of</span>
<span class="cm"> * |nva| of length |nvlen|.</span>
<span class="cm"> */</span>
<span class="kt">size_t</span> <span class="nf">nghttp2_hd_deflate_bound</span><span class="p">(</span><span class="n">nghttp2_hd_deflater</span> <span class="o">*</span><span class="n">deflater</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">nghttp2_hd_inflater</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * HPACK inflater object.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">nghttp2_hd_inflater</span> <span class="n">nghttp2_hd_inflater</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |*inflater_ptr| for inflating name/values pairs.</span>
<span class="cm"> *</span>
<span class="cm"> * If this function fails, |*inflater_ptr| is left untouched.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_hd_inflate_new</span><span class="p">(</span><span class="n">nghttp2_hd_inflater</span> <span class="o">**</span><span class="n">inflater_ptr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Like `nghttp2_hd_inflate_new()`, but with additional custom memory</span>
<span class="cm"> * allocator specified in the |mem|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |mem| can be ``NULL`` and the call is equivalent to</span>
<span class="cm"> * `nghttp2_hd_inflate_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership |mem|.  The application is</span>
<span class="cm"> * responsible for freeing |mem|.</span>
<span class="cm"> *</span>
<span class="cm"> * The library code does not refer to |mem| pointer after this</span>
<span class="cm"> * function returns, so the application can safely free it.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_hd_inflate_new2</span><span class="p">(</span><span class="n">nghttp2_hd_inflater</span> <span class="o">**</span><span class="n">inflater_ptr</span><span class="p">,</span>
                            <span class="n">nghttp2_mem</span> <span class="o">*</span><span class="n">mem</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Deallocates any resources allocated for |inflater|.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_hd_inflate_del</span><span class="p">(</span><span class="n">nghttp2_hd_inflater</span> <span class="o">*</span><span class="n">inflater</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Changes header table size in the |inflater|.  This may trigger</span>
<span class="cm"> * eviction in the dynamic table.</span>
<span class="cm"> *</span>
<span class="cm"> * The |settings_hd_table_bufsize_max| should be the value transmitted</span>
<span class="cm"> * in SETTINGS_HEADER_TABLE_SIZE.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_hd_inflate_change_table_size</span><span class="p">(</span><span class="n">nghttp2_hd_inflater</span> <span class="o">*</span><span class="n">inflater</span><span class="p">,</span>
                                         <span class="kt">size_t</span> <span class="n">settings_hd_table_bufsize_max</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * The flags for header inflation.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * No flag set.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HD_INFLATE_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Indicates all headers were inflated.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HD_INFLATE_FINAL</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Indicates a header was emitted.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HD_INFLATE_EMIT</span> <span class="o">=</span> <span class="mh">0x02</span>
<span class="p">}</span> <span class="n">nghttp2_hd_inflate_flag</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Inflates name/value block stored in |in| with length |inlen|.  This</span>
<span class="cm"> * function performs decompression.  For each successful emission of</span>
<span class="cm"> * header name/value pair, :enum:`NGHTTP2_HD_INFLATE_EMIT` is set in</span>
<span class="cm"> * |*inflate_flags| and name/value pair is assigned to the |nv_out|</span>
<span class="cm"> * and the function returns.  The caller must not free the members of</span>
<span class="cm"> * |nv_out|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |nv_out| may include pointers to the memory region in the |in|.</span>
<span class="cm"> * The caller must retain the |in| while the |nv_out| is used.</span>
<span class="cm"> *</span>
<span class="cm"> * The application should call this function repeatedly until the</span>
<span class="cm"> * ``(*inflate_flags) &amp; NGHTTP2_HD_INFLATE_FINAL`` is nonzero and</span>
<span class="cm"> * return value is non-negative.  This means the all input values are</span>
<span class="cm"> * processed successfully.  Then the application must call</span>
<span class="cm"> * `nghttp2_hd_inflate_end_headers()` to prepare for the next header</span>
<span class="cm"> * block input.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller can feed complete compressed header block.  It also can</span>
<span class="cm"> * feed it in several chunks.  The caller must set |in_final| to</span>
<span class="cm"> * nonzero if the given input is the last block of the compressed</span>
<span class="cm"> * header.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of bytes processed if it succeeds,</span>
<span class="cm"> * or one of the following negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_HEADER_COMP`</span>
<span class="cm"> *     Inflation process has failed.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_BUFFER_ERROR`</span>
<span class="cm"> *     The heder field name or value is too large.</span>
<span class="cm"> *</span>
<span class="cm"> * Example follows::</span>
<span class="cm"> *</span>
<span class="cm"> *     int inflate_header_block(nghttp2_hd_inflater *hd_inflater,</span>
<span class="cm"> *                              uint8_t *in, size_t inlen, int final)</span>
<span class="cm"> *     {</span>
<span class="cm"> *         ssize_t rv;</span>
<span class="cm"> *</span>
<span class="cm"> *         for(;;) {</span>
<span class="cm"> *             nghttp2_nv nv;</span>
<span class="cm"> *             int inflate_flags = 0;</span>
<span class="cm"> *</span>
<span class="cm"> *             rv = nghttp2_hd_inflate_hd(hd_inflater, &amp;nv, &amp;inflate_flags,</span>
<span class="cm"> *                                        in, inlen, final);</span>
<span class="cm"> *</span>
<span class="cm"> *             if(rv &lt; 0) {</span>
<span class="cm"> *                 fprintf(stderr, &quot;inflate failed with error code %zd&quot;, rv);</span>
<span class="cm"> *                 return -1;</span>
<span class="cm"> *             }</span>
<span class="cm"> *</span>
<span class="cm"> *             in += rv;</span>
<span class="cm"> *             inlen -= rv;</span>
<span class="cm"> *</span>
<span class="cm"> *             if(inflate_flags &amp; NGHTTP2_HD_INFLATE_EMIT) {</span>
<span class="cm"> *                 fwrite(nv.name, nv.namelen, 1, stderr);</span>
<span class="cm"> *                 fprintf(stderr, &quot;: &quot;);</span>
<span class="cm"> *                 fwrite(nv.value, nv.valuelen, 1, stderr);</span>
<span class="cm"> *                 fprintf(stderr, &quot;\n&quot;);</span>
<span class="cm"> *             }</span>
<span class="cm"> *             if(inflate_flags &amp; NGHTTP2_HD_INFLATE_FINAL) {</span>
<span class="cm"> *                 nghttp2_hd_inflate_end_headers(hd_inflater);</span>
<span class="cm"> *                 break;</span>
<span class="cm"> *             }</span>
<span class="cm"> *             if((inflate_flags &amp; NGHTTP2_HD_INFLATE_EMIT) == 0 &amp;&amp;</span>
<span class="cm"> *                inlen == 0) {</span>
<span class="cm"> *                break;</span>
<span class="cm"> *             }</span>
<span class="cm"> *         }</span>
<span class="cm"> *</span>
<span class="cm"> *         return 0;</span>
<span class="cm"> *     }</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nghttp2_hd_inflate_hd</span><span class="p">(</span><span class="n">nghttp2_hd_inflater</span> <span class="o">*</span><span class="n">inflater</span><span class="p">,</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nv_out</span><span class="p">,</span>
                              <span class="kt">int</span> <span class="o">*</span><span class="n">inflate_flags</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">inlen</span><span class="p">,</span>
                              <span class="kt">int</span> <span class="n">in_final</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Signals the end of decompression for one header block.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds. Currently this function</span>
<span class="cm"> * always succeeds.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_hd_inflate_end_headers</span><span class="p">(</span><span class="n">nghttp2_hd_inflater</span> <span class="o">*</span><span class="n">inflater</span><span class="p">);</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* NGHTTP2_H */</span><span class="cp"></span>
</pre></div>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="nghttp2ver.h.html" class="btn btn-neutral float-right" title="nghttp2ver.h">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="python-apiref.html" class="btn btn-neutral" title="Python API Reference"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2012, 2015, Tatsuhiro Tsujikawa.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.7.8-DEV',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>